// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package deduplication

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [Deduplication rules](https://support.squadcast.com/docs/de-duplication-rules) can help you reduce alert noise by organising and grouping alerts. This also provides easy access to similar alerts when needed. When these rules evaluate to true for an incoming incident, alerts will get deduplicated.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast"
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/deduplication"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "example team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleService, err := squadcast.LookupService(ctx, &squadcast.LookupServiceArgs{
//				Name:   "example service name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = deduplication.NewRules(ctx, "exampleDeduplicationRules", &deduplication.RulesArgs{
//				TeamId:    pulumi.String(exampleTeam.Id),
//				ServiceId: pulumi.String(exampleService.Id),
//				Rules: deduplication.RulesRuleArray{
//					&deduplication.RulesRuleArgs{
//						IsBasic:     pulumi.Bool(false),
//						Description: pulumi.String("not basic"),
//						Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//					},
//					&deduplication.RulesRuleArgs{
//						IsBasic:     pulumi.Bool(true),
//						Description: pulumi.String("basic"),
//						BasicExpressions: deduplication.RulesRuleBasicExpressionArray{
//							&deduplication.RulesRuleBasicExpressionArgs{
//								Lhs: pulumi.String("payload[\"foo\"]"),
//								Op:  pulumi.String("is"),
//								Rhs: pulumi.String("bar"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// teamID:serviceID
//
// Use 'Get All Teams' and 'Get All Services' APIs to get the id of the team and service respectively
//
// ```sh
// $ pulumi import squadcast:deduplication/rules:Rules test_resource_name 62d2fe23a57381088224d726:62da76c088f407f9ca756ca5
// ```
type Rules struct {
	pulumi.CustomResourceState

	Rules RulesRuleArrayOutput `pulumi:"rules"`
	// Service id.
	ServiceId pulumi.StringOutput `pulumi:"serviceId"`
	// Team id.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
}

// NewRules registers a new resource with the given unique name, arguments, and options.
func NewRules(ctx *pulumi.Context,
	name string, args *RulesArgs, opts ...pulumi.ResourceOption) (*Rules, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	if args.ServiceId == nil {
		return nil, errors.New("invalid value for required argument 'ServiceId'")
	}
	if args.TeamId == nil {
		return nil, errors.New("invalid value for required argument 'TeamId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Rules
	err := ctx.RegisterResource("squadcast:deduplication/rules:Rules", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRules gets an existing Rules resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRules(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RulesState, opts ...pulumi.ResourceOption) (*Rules, error) {
	var resource Rules
	err := ctx.ReadResource("squadcast:deduplication/rules:Rules", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Rules resources.
type rulesState struct {
	Rules []RulesRule `pulumi:"rules"`
	// Service id.
	ServiceId *string `pulumi:"serviceId"`
	// Team id.
	TeamId *string `pulumi:"teamId"`
}

type RulesState struct {
	Rules RulesRuleArrayInput
	// Service id.
	ServiceId pulumi.StringPtrInput
	// Team id.
	TeamId pulumi.StringPtrInput
}

func (RulesState) ElementType() reflect.Type {
	return reflect.TypeOf((*rulesState)(nil)).Elem()
}

type rulesArgs struct {
	Rules []RulesRule `pulumi:"rules"`
	// Service id.
	ServiceId string `pulumi:"serviceId"`
	// Team id.
	TeamId string `pulumi:"teamId"`
}

// The set of arguments for constructing a Rules resource.
type RulesArgs struct {
	Rules RulesRuleArrayInput
	// Service id.
	ServiceId pulumi.StringInput
	// Team id.
	TeamId pulumi.StringInput
}

func (RulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rulesArgs)(nil)).Elem()
}

type RulesInput interface {
	pulumi.Input

	ToRulesOutput() RulesOutput
	ToRulesOutputWithContext(ctx context.Context) RulesOutput
}

func (*Rules) ElementType() reflect.Type {
	return reflect.TypeOf((**Rules)(nil)).Elem()
}

func (i *Rules) ToRulesOutput() RulesOutput {
	return i.ToRulesOutputWithContext(context.Background())
}

func (i *Rules) ToRulesOutputWithContext(ctx context.Context) RulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesOutput)
}

// RulesArrayInput is an input type that accepts RulesArray and RulesArrayOutput values.
// You can construct a concrete instance of `RulesArrayInput` via:
//
//	RulesArray{ RulesArgs{...} }
type RulesArrayInput interface {
	pulumi.Input

	ToRulesArrayOutput() RulesArrayOutput
	ToRulesArrayOutputWithContext(context.Context) RulesArrayOutput
}

type RulesArray []RulesInput

func (RulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rules)(nil)).Elem()
}

func (i RulesArray) ToRulesArrayOutput() RulesArrayOutput {
	return i.ToRulesArrayOutputWithContext(context.Background())
}

func (i RulesArray) ToRulesArrayOutputWithContext(ctx context.Context) RulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesArrayOutput)
}

// RulesMapInput is an input type that accepts RulesMap and RulesMapOutput values.
// You can construct a concrete instance of `RulesMapInput` via:
//
//	RulesMap{ "key": RulesArgs{...} }
type RulesMapInput interface {
	pulumi.Input

	ToRulesMapOutput() RulesMapOutput
	ToRulesMapOutputWithContext(context.Context) RulesMapOutput
}

type RulesMap map[string]RulesInput

func (RulesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rules)(nil)).Elem()
}

func (i RulesMap) ToRulesMapOutput() RulesMapOutput {
	return i.ToRulesMapOutputWithContext(context.Background())
}

func (i RulesMap) ToRulesMapOutputWithContext(ctx context.Context) RulesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RulesMapOutput)
}

type RulesOutput struct{ *pulumi.OutputState }

func (RulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Rules)(nil)).Elem()
}

func (o RulesOutput) ToRulesOutput() RulesOutput {
	return o
}

func (o RulesOutput) ToRulesOutputWithContext(ctx context.Context) RulesOutput {
	return o
}

func (o RulesOutput) Rules() RulesRuleArrayOutput {
	return o.ApplyT(func(v *Rules) RulesRuleArrayOutput { return v.Rules }).(RulesRuleArrayOutput)
}

// Service id.
func (o RulesOutput) ServiceId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rules) pulumi.StringOutput { return v.ServiceId }).(pulumi.StringOutput)
}

// Team id.
func (o RulesOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *Rules) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

type RulesArrayOutput struct{ *pulumi.OutputState }

func (RulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Rules)(nil)).Elem()
}

func (o RulesArrayOutput) ToRulesArrayOutput() RulesArrayOutput {
	return o
}

func (o RulesArrayOutput) ToRulesArrayOutputWithContext(ctx context.Context) RulesArrayOutput {
	return o
}

func (o RulesArrayOutput) Index(i pulumi.IntInput) RulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Rules {
		return vs[0].([]*Rules)[vs[1].(int)]
	}).(RulesOutput)
}

type RulesMapOutput struct{ *pulumi.OutputState }

func (RulesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Rules)(nil)).Elem()
}

func (o RulesMapOutput) ToRulesMapOutput() RulesMapOutput {
	return o
}

func (o RulesMapOutput) ToRulesMapOutputWithContext(ctx context.Context) RulesMapOutput {
	return o
}

func (o RulesMapOutput) MapIndex(k pulumi.StringInput) RulesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Rules {
		return vs[0].(map[string]*Rules)[vs[1].(string)]
	}).(RulesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RulesInput)(nil)).Elem(), &Rules{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesArrayInput)(nil)).Elem(), RulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RulesMapInput)(nil)).Elem(), RulesMap{})
	pulumi.RegisterOutputType(RulesOutput{})
	pulumi.RegisterOutputType(RulesArrayOutput{})
	pulumi.RegisterOutputType(RulesMapOutput{})
}
