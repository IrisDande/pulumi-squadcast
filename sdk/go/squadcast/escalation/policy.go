// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package escalation

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [Escalation Policies](https://support.squadcast.com/docs/escalation-policies) defines rules indicating when and how alerts will escalate to various Users, Squads and (or) Schedules within your Organization. The name of the Escalation Policy must be unique within and across Teams.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast"
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/escalation"
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/schedule"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "example team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleUser, err := squadcast.LookupUser(ctx, &squadcast.LookupUserArgs{
//				Email: "test@example.com",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleSquad, err := squadcast.LookupSquad(ctx, &squadcast.LookupSquadArgs{
//				Name:   "example squad name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleScheduleV2, err := schedule.LookupV2(ctx, &schedule.LookupV2Args{
//				Name:   "example schedule name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = escalation.NewPolicy(ctx, "exampleEscalaionPolicy", &escalation.PolicyArgs{
//				Description: pulumi.String("It's an amazing policy"),
//				TeamId:      pulumi.String(exampleTeam.Id),
//				Rules: escalation.PolicyRuleArray{
//					&escalation.PolicyRuleArgs{
//						DelayMinutes: pulumi.Int(0),
//						Targets: escalation.PolicyRuleTargetArray{
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleUser.Id),
//								Type: pulumi.String("user"),
//							},
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleScheduleV2.Id),
//								Type: pulumi.String("schedulev2"),
//							},
//						},
//					},
//					&escalation.PolicyRuleArgs{
//						DelayMinutes: pulumi.Int(5),
//						Targets: escalation.PolicyRuleTargetArray{
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleUser.Id),
//								Type: pulumi.String("user"),
//							},
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleSquad.Id),
//								Type: pulumi.String("squad"),
//							},
//						},
//						NotificationChannels: pulumi.StringArray{
//							pulumi.String("Phone"),
//						},
//						Repeat: &escalation.PolicyRuleRepeatArgs{
//							Times:        pulumi.Int(1),
//							DelayMinutes: pulumi.Int(5),
//						},
//					},
//					&escalation.PolicyRuleArgs{
//						DelayMinutes: pulumi.Int(10),
//						Targets: escalation.PolicyRuleTargetArray{
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleSquad.Id),
//								Type: pulumi.String("squad"),
//							},
//							&escalation.PolicyRuleTargetArgs{
//								Id:   pulumi.String(exampleScheduleV2.Id),
//								Type: pulumi.String("schedulev2"),
//							},
//						},
//						RoundRobin: &escalation.PolicyRuleRoundRobinArgs{
//							Enabled: pulumi.Bool(true),
//							Rotation: &escalation.PolicyRuleRoundRobinRotationArgs{
//								Enabled:      pulumi.Bool(true),
//								DelayMinutes: pulumi.Int(1),
//							},
//						},
//					},
//				},
//				Repeat: &escalation.PolicyRepeatArgs{
//					Times:        pulumi.Int(2),
//					DelayMinutes: pulumi.Int(10),
//				},
//				EntityOwner: &escalation.PolicyEntityOwnerArgs{
//					Id:   pulumi.String(exampleUser.Id),
//					Type: pulumi.String("user"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// teamID:escalationPolicyID
//
// Use 'Get All Teams' and 'Get All Escalation Policies' APIs to get the id of the team and escalation policy name respectively
//
// ```sh
// $ pulumi import squadcast:escalation/policy:Policy test "62d2fe23a57381088224d726:Example Escalation Policy"
// ```
type Policy struct {
	pulumi.CustomResourceState

	// Detailed description about the Escalation Policy.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Escalation policy owner.
	EntityOwner PolicyEntityOwnerOutput `pulumi:"entityOwner"`
	// Name of the Escalation Policy.
	Name pulumi.StringOutput `pulumi:"name"`
	// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
	Repeat PolicyRepeatPtrOutput `pulumi:"repeat"`
	// Rules will have the details of who to notify and when to notify and how to notify them.
	Rules PolicyRuleArrayOutput `pulumi:"rules"`
	// Team id.
	TeamId pulumi.StringOutput `pulumi:"teamId"`
}

// NewPolicy registers a new resource with the given unique name, arguments, and options.
func NewPolicy(ctx *pulumi.Context,
	name string, args *PolicyArgs, opts ...pulumi.ResourceOption) (*Policy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntityOwner == nil {
		return nil, errors.New("invalid value for required argument 'EntityOwner'")
	}
	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	if args.TeamId == nil {
		return nil, errors.New("invalid value for required argument 'TeamId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Policy
	err := ctx.RegisterResource("squadcast:escalation/policy:Policy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicy gets an existing Policy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyState, opts ...pulumi.ResourceOption) (*Policy, error) {
	var resource Policy
	err := ctx.ReadResource("squadcast:escalation/policy:Policy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Policy resources.
type policyState struct {
	// Detailed description about the Escalation Policy.
	Description *string `pulumi:"description"`
	// Escalation policy owner.
	EntityOwner *PolicyEntityOwner `pulumi:"entityOwner"`
	// Name of the Escalation Policy.
	Name *string `pulumi:"name"`
	// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
	Repeat *PolicyRepeat `pulumi:"repeat"`
	// Rules will have the details of who to notify and when to notify and how to notify them.
	Rules []PolicyRule `pulumi:"rules"`
	// Team id.
	TeamId *string `pulumi:"teamId"`
}

type PolicyState struct {
	// Detailed description about the Escalation Policy.
	Description pulumi.StringPtrInput
	// Escalation policy owner.
	EntityOwner PolicyEntityOwnerPtrInput
	// Name of the Escalation Policy.
	Name pulumi.StringPtrInput
	// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
	Repeat PolicyRepeatPtrInput
	// Rules will have the details of who to notify and when to notify and how to notify them.
	Rules PolicyRuleArrayInput
	// Team id.
	TeamId pulumi.StringPtrInput
}

func (PolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyState)(nil)).Elem()
}

type policyArgs struct {
	// Detailed description about the Escalation Policy.
	Description *string `pulumi:"description"`
	// Escalation policy owner.
	EntityOwner PolicyEntityOwner `pulumi:"entityOwner"`
	// Name of the Escalation Policy.
	Name *string `pulumi:"name"`
	// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
	Repeat *PolicyRepeat `pulumi:"repeat"`
	// Rules will have the details of who to notify and when to notify and how to notify them.
	Rules []PolicyRule `pulumi:"rules"`
	// Team id.
	TeamId string `pulumi:"teamId"`
}

// The set of arguments for constructing a Policy resource.
type PolicyArgs struct {
	// Detailed description about the Escalation Policy.
	Description pulumi.StringPtrInput
	// Escalation policy owner.
	EntityOwner PolicyEntityOwnerInput
	// Name of the Escalation Policy.
	Name pulumi.StringPtrInput
	// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
	Repeat PolicyRepeatPtrInput
	// Rules will have the details of who to notify and when to notify and how to notify them.
	Rules PolicyRuleArrayInput
	// Team id.
	TeamId pulumi.StringInput
}

func (PolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyArgs)(nil)).Elem()
}

type PolicyInput interface {
	pulumi.Input

	ToPolicyOutput() PolicyOutput
	ToPolicyOutputWithContext(ctx context.Context) PolicyOutput
}

func (*Policy) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (i *Policy) ToPolicyOutput() PolicyOutput {
	return i.ToPolicyOutputWithContext(context.Background())
}

func (i *Policy) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyOutput)
}

// PolicyArrayInput is an input type that accepts PolicyArray and PolicyArrayOutput values.
// You can construct a concrete instance of `PolicyArrayInput` via:
//
//	PolicyArray{ PolicyArgs{...} }
type PolicyArrayInput interface {
	pulumi.Input

	ToPolicyArrayOutput() PolicyArrayOutput
	ToPolicyArrayOutputWithContext(context.Context) PolicyArrayOutput
}

type PolicyArray []PolicyInput

func (PolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (i PolicyArray) ToPolicyArrayOutput() PolicyArrayOutput {
	return i.ToPolicyArrayOutputWithContext(context.Background())
}

func (i PolicyArray) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyArrayOutput)
}

// PolicyMapInput is an input type that accepts PolicyMap and PolicyMapOutput values.
// You can construct a concrete instance of `PolicyMapInput` via:
//
//	PolicyMap{ "key": PolicyArgs{...} }
type PolicyMapInput interface {
	pulumi.Input

	ToPolicyMapOutput() PolicyMapOutput
	ToPolicyMapOutputWithContext(context.Context) PolicyMapOutput
}

type PolicyMap map[string]PolicyInput

func (PolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (i PolicyMap) ToPolicyMapOutput() PolicyMapOutput {
	return i.ToPolicyMapOutputWithContext(context.Background())
}

func (i PolicyMap) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapOutput)
}

type PolicyOutput struct{ *pulumi.OutputState }

func (PolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Policy)(nil)).Elem()
}

func (o PolicyOutput) ToPolicyOutput() PolicyOutput {
	return o
}

func (o PolicyOutput) ToPolicyOutputWithContext(ctx context.Context) PolicyOutput {
	return o
}

// Detailed description about the Escalation Policy.
func (o PolicyOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Escalation policy owner.
func (o PolicyOutput) EntityOwner() PolicyEntityOwnerOutput {
	return o.ApplyT(func(v *Policy) PolicyEntityOwnerOutput { return v.EntityOwner }).(PolicyEntityOwnerOutput)
}

// Name of the Escalation Policy.
func (o PolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
func (o PolicyOutput) Repeat() PolicyRepeatPtrOutput {
	return o.ApplyT(func(v *Policy) PolicyRepeatPtrOutput { return v.Repeat }).(PolicyRepeatPtrOutput)
}

// Rules will have the details of who to notify and when to notify and how to notify them.
func (o PolicyOutput) Rules() PolicyRuleArrayOutput {
	return o.ApplyT(func(v *Policy) PolicyRuleArrayOutput { return v.Rules }).(PolicyRuleArrayOutput)
}

// Team id.
func (o PolicyOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *Policy) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

type PolicyArrayOutput struct{ *pulumi.OutputState }

func (PolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Policy)(nil)).Elem()
}

func (o PolicyArrayOutput) ToPolicyArrayOutput() PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) ToPolicyArrayOutputWithContext(ctx context.Context) PolicyArrayOutput {
	return o
}

func (o PolicyArrayOutput) Index(i pulumi.IntInput) PolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].([]*Policy)[vs[1].(int)]
	}).(PolicyOutput)
}

type PolicyMapOutput struct{ *pulumi.OutputState }

func (PolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Policy)(nil)).Elem()
}

func (o PolicyMapOutput) ToPolicyMapOutput() PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) MapIndex(k pulumi.StringInput) PolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Policy {
		return vs[0].(map[string]*Policy)[vs[1].(string)]
	}).(PolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyInput)(nil)).Elem(), &Policy{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyArrayInput)(nil)).Elem(), PolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapInput)(nil)).Elem(), PolicyMap{})
	pulumi.RegisterOutputType(PolicyOutput{})
	pulumi.RegisterOutputType(PolicyArrayOutput{})
	pulumi.RegisterOutputType(PolicyMapOutput{})
}
