// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package squadcast

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// `Slo` manages an SLO. The name of the SLO must be unique within a Team.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "example team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleUser, err := squadcast.LookupUser(ctx, &squadcast.LookupUserArgs{
//				Email: "test@example.com",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleService, err := squadcast.LookupService(ctx, &squadcast.LookupServiceArgs{
//				Name:   "example service name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSlo(ctx, "exampleSlo", &squadcast.SloArgs{
//				TeamId:      pulumi.String(exampleTeam.Id),
//				Description: pulumi.String("Slo for checkout flow"),
//				TargetSlo:   pulumi.Float64(99.99),
//				ServiceIds: pulumi.StringArray{
//					pulumi.String(exampleService.Id),
//				},
//				Slis: pulumi.StringArray{
//					pulumi.String("latency"),
//					pulumi.String("high-err-rate"),
//				},
//				TimeIntervalType: pulumi.String("rolling"),
//				DurationInDays:   pulumi.Int(7),
//				Rules: squadcast.SloRuleArray{
//					&squadcast.SloRuleArgs{
//						Name: pulumi.String("breached_error_budget"),
//					},
//					&squadcast.SloRuleArgs{
//						Name:      pulumi.String("remaining_error_budget"),
//						Threshold: pulumi.Int(11),
//					},
//					&squadcast.SloRuleArgs{
//						Name:      pulumi.String("unhealthy_slo"),
//						Threshold: pulumi.Int(1),
//					},
//				},
//				Notify: &squadcast.SloNotifyArgs{
//					UserIds: pulumi.StringArray{
//						pulumi.String(exampleUser.Id),
//					},
//				},
//				EntityOwner: &squadcast.SloEntityOwnerArgs{
//					Id:   pulumi.String(exampleUser.Id),
//					Type: pulumi.String("user"),
//				},
//				Tags: pulumi.StringMap{
//					"tagKey":  pulumi.String("tagValue"),
//					"tagKey2": pulumi.String("tagValue2"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// teamID:sloID
//
// Use 'Get All Teams' and 'Get All Slos' APIs to get the id of the team and slo respectively
//
// ```sh
// $ pulumi import squadcast:index/slo:Slo test 61443b953ffd52818bf1617a:1023
// ```
type Slo struct {
	pulumi.CustomResourceState

	// Description of the SLO.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntOutput `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringOutput `pulumi:"endTime"`
	// SLO owner.
	EntityOwner SloEntityOwnerOutput `pulumi:"entityOwner"`
	// The name of the SLO.
	Name pulumi.StringOutput `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SloNotifyPtrOutput `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SloRuleArrayOutput `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayOutput `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayOutput `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringOutput `pulumi:"startTime"`
	// SLO Tags.
	Tags pulumi.StringMapOutput `pulumi:"tags"`
	// The target SLO for the time period.
	TargetSlo pulumi.Float64Output `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId pulumi.StringOutput `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringOutput `pulumi:"timeIntervalType"`
}

// NewSlo registers a new resource with the given unique name, arguments, and options.
func NewSlo(ctx *pulumi.Context,
	name string, args *SloArgs, opts ...pulumi.ResourceOption) (*Slo, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.EntityOwner == nil {
		return nil, errors.New("invalid value for required argument 'EntityOwner'")
	}
	if args.ServiceIds == nil {
		return nil, errors.New("invalid value for required argument 'ServiceIds'")
	}
	if args.Slis == nil {
		return nil, errors.New("invalid value for required argument 'Slis'")
	}
	if args.TargetSlo == nil {
		return nil, errors.New("invalid value for required argument 'TargetSlo'")
	}
	if args.TeamId == nil {
		return nil, errors.New("invalid value for required argument 'TeamId'")
	}
	if args.TimeIntervalType == nil {
		return nil, errors.New("invalid value for required argument 'TimeIntervalType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Slo
	err := ctx.RegisterResource("squadcast:index/slo:Slo", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSlo gets an existing Slo resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSlo(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SloState, opts ...pulumi.ResourceOption) (*Slo, error) {
	var resource Slo
	err := ctx.ReadResource("squadcast:index/slo:Slo", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Slo resources.
type sloState struct {
	// Description of the SLO.
	Description *string `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays *int `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime *string `pulumi:"endTime"`
	// SLO owner.
	EntityOwner *SloEntityOwner `pulumi:"entityOwner"`
	// The name of the SLO.
	Name *string `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify *SloNotify `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules []SloRule `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds []string `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis []string `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime *string `pulumi:"startTime"`
	// SLO Tags.
	Tags map[string]string `pulumi:"tags"`
	// The target SLO for the time period.
	TargetSlo *float64 `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId *string `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType *string `pulumi:"timeIntervalType"`
}

type SloState struct {
	// Description of the SLO.
	Description pulumi.StringPtrInput
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntPtrInput
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringPtrInput
	// SLO owner.
	EntityOwner SloEntityOwnerPtrInput
	// The name of the SLO.
	Name pulumi.StringPtrInput
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SloNotifyPtrInput
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SloRuleArrayInput
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayInput
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayInput
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringPtrInput
	// SLO Tags.
	Tags pulumi.StringMapInput
	// The target SLO for the time period.
	TargetSlo pulumi.Float64PtrInput
	// The team which SLO resource belongs to
	TeamId pulumi.StringPtrInput
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringPtrInput
}

func (SloState) ElementType() reflect.Type {
	return reflect.TypeOf((*sloState)(nil)).Elem()
}

type sloArgs struct {
	// Description of the SLO.
	Description *string `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays *int `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime *string `pulumi:"endTime"`
	// SLO owner.
	EntityOwner SloEntityOwner `pulumi:"entityOwner"`
	// The name of the SLO.
	Name *string `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify *SloNotify `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules []SloRule `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds []string `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis []string `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime *string `pulumi:"startTime"`
	// SLO Tags.
	Tags map[string]string `pulumi:"tags"`
	// The target SLO for the time period.
	TargetSlo float64 `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId string `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType string `pulumi:"timeIntervalType"`
}

// The set of arguments for constructing a Slo resource.
type SloArgs struct {
	// Description of the SLO.
	Description pulumi.StringPtrInput
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntPtrInput
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringPtrInput
	// SLO owner.
	EntityOwner SloEntityOwnerInput
	// The name of the SLO.
	Name pulumi.StringPtrInput
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SloNotifyPtrInput
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SloRuleArrayInput
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayInput
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayInput
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringPtrInput
	// SLO Tags.
	Tags pulumi.StringMapInput
	// The target SLO for the time period.
	TargetSlo pulumi.Float64Input
	// The team which SLO resource belongs to
	TeamId pulumi.StringInput
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringInput
}

func (SloArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sloArgs)(nil)).Elem()
}

type SloInput interface {
	pulumi.Input

	ToSloOutput() SloOutput
	ToSloOutputWithContext(ctx context.Context) SloOutput
}

func (*Slo) ElementType() reflect.Type {
	return reflect.TypeOf((**Slo)(nil)).Elem()
}

func (i *Slo) ToSloOutput() SloOutput {
	return i.ToSloOutputWithContext(context.Background())
}

func (i *Slo) ToSloOutputWithContext(ctx context.Context) SloOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloOutput)
}

// SloArrayInput is an input type that accepts SloArray and SloArrayOutput values.
// You can construct a concrete instance of `SloArrayInput` via:
//
//	SloArray{ SloArgs{...} }
type SloArrayInput interface {
	pulumi.Input

	ToSloArrayOutput() SloArrayOutput
	ToSloArrayOutputWithContext(context.Context) SloArrayOutput
}

type SloArray []SloInput

func (SloArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slo)(nil)).Elem()
}

func (i SloArray) ToSloArrayOutput() SloArrayOutput {
	return i.ToSloArrayOutputWithContext(context.Background())
}

func (i SloArray) ToSloArrayOutputWithContext(ctx context.Context) SloArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloArrayOutput)
}

// SloMapInput is an input type that accepts SloMap and SloMapOutput values.
// You can construct a concrete instance of `SloMapInput` via:
//
//	SloMap{ "key": SloArgs{...} }
type SloMapInput interface {
	pulumi.Input

	ToSloMapOutput() SloMapOutput
	ToSloMapOutputWithContext(context.Context) SloMapOutput
}

type SloMap map[string]SloInput

func (SloMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slo)(nil)).Elem()
}

func (i SloMap) ToSloMapOutput() SloMapOutput {
	return i.ToSloMapOutputWithContext(context.Background())
}

func (i SloMap) ToSloMapOutputWithContext(ctx context.Context) SloMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloMapOutput)
}

type SloOutput struct{ *pulumi.OutputState }

func (SloOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Slo)(nil)).Elem()
}

func (o SloOutput) ToSloOutput() SloOutput {
	return o
}

func (o SloOutput) ToSloOutputWithContext(ctx context.Context) SloOutput {
	return o
}

// Description of the SLO.
func (o SloOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
func (o SloOutput) DurationInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *Slo) pulumi.IntOutput { return v.DurationInDays }).(pulumi.IntOutput)
}

// SLO end time. Required only when SLO time interval type set to "fixed"
func (o SloOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.EndTime }).(pulumi.StringOutput)
}

// SLO owner.
func (o SloOutput) EntityOwner() SloEntityOwnerOutput {
	return o.ApplyT(func(v *Slo) SloEntityOwnerOutput { return v.EntityOwner }).(SloEntityOwnerOutput)
}

// The name of the SLO.
func (o SloOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
func (o SloOutput) Notify() SloNotifyPtrOutput {
	return o.ApplyT(func(v *Slo) SloNotifyPtrOutput { return v.Notify }).(SloNotifyPtrOutput)
}

// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
func (o SloOutput) Rules() SloRuleArrayOutput {
	return o.ApplyT(func(v *Slo) SloRuleArrayOutput { return v.Rules }).(SloRuleArrayOutput)
}

// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
func (o SloOutput) ServiceIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringArrayOutput { return v.ServiceIds }).(pulumi.StringArrayOutput)
}

// List of indentified SLIs for the SLO
func (o SloOutput) Slis() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringArrayOutput { return v.Slis }).(pulumi.StringArrayOutput)
}

// SLO start time. Required only when SLO time interval type set to "fixed"
func (o SloOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.StartTime }).(pulumi.StringOutput)
}

// SLO Tags.
func (o SloOutput) Tags() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringMapOutput { return v.Tags }).(pulumi.StringMapOutput)
}

// The target SLO for the time period.
func (o SloOutput) TargetSlo() pulumi.Float64Output {
	return o.ApplyT(func(v *Slo) pulumi.Float64Output { return v.TargetSlo }).(pulumi.Float64Output)
}

// The team which SLO resource belongs to
func (o SloOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

// Type of the SLO. Values can either be "rolling" or "fixed"
func (o SloOutput) TimeIntervalType() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.TimeIntervalType }).(pulumi.StringOutput)
}

type SloArrayOutput struct{ *pulumi.OutputState }

func (SloArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slo)(nil)).Elem()
}

func (o SloArrayOutput) ToSloArrayOutput() SloArrayOutput {
	return o
}

func (o SloArrayOutput) ToSloArrayOutputWithContext(ctx context.Context) SloArrayOutput {
	return o
}

func (o SloArrayOutput) Index(i pulumi.IntInput) SloOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Slo {
		return vs[0].([]*Slo)[vs[1].(int)]
	}).(SloOutput)
}

type SloMapOutput struct{ *pulumi.OutputState }

func (SloMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slo)(nil)).Elem()
}

func (o SloMapOutput) ToSloMapOutput() SloMapOutput {
	return o
}

func (o SloMapOutput) ToSloMapOutputWithContext(ctx context.Context) SloMapOutput {
	return o
}

func (o SloMapOutput) MapIndex(k pulumi.StringInput) SloOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Slo {
		return vs[0].(map[string]*Slo)[vs[1].(string)]
	}).(SloOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SloInput)(nil)).Elem(), &Slo{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloArrayInput)(nil)).Elem(), SloArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloMapInput)(nil)).Elem(), SloMap{})
	pulumi.RegisterOutputType(SloOutput{})
	pulumi.RegisterOutputType(SloArrayOutput{})
	pulumi.RegisterOutputType(SloMapOutput{})
}
