// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rule

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [Suppression rules](https://support.squadcast.com/docs/alert-suppression) can help you avoid alert fatigue by suppressing notifications for non-actionable alerts.Squadcast will suppress the incidents that match any of the Suppression Rules you create for your Services. These incidents will go into the Suppressed state and you will not get any notifications for them
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast"
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/suppression"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "exammple team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleService, err := squadcast.LookupService(ctx, &squadcast.LookupServiceArgs{
//				Name:   "example service name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = suppression.NewV2(ctx, "exampleBasicSuppressionRules", &suppression.V2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(true),
//				Description: pulumi.String("sample basic expression"),
//				BasicExpressions: rule.V2BasicExpressionArray{
//					&rule.V2BasicExpressionArgs{
//						Lhs: pulumi.String("abc"),
//						Op:  pulumi.String("is"),
//						Rhs: pulumi.String("xyz"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = suppression.NewV2(ctx, "exampleSuppressionRules", &suppression.V2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = suppression.NewV2(ctx, "exampleTimeBasedSuppressionRules", &suppression.V2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//				Timeslots: rule.V2TimeslotArray{
//					&rule.V2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("none"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = suppression.NewV2(ctx, "exampleTimeBasedSuppressionRulesCustomRepetition", &suppression.V2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//				Timeslots: rule.V2TimeslotArray{
//					&rule.V2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: rule.V2TimeslotCustomArray{
//							&rule.V2TimeslotCustomArgs{
//								Repeats:      pulumi.String("day"),
//								RepeatsCount: pulumi.Int(2),
//							},
//						},
//					},
//					&rule.V2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: rule.V2TimeslotCustomArray{
//							&rule.V2TimeslotCustomArgs{
//								Repeats:      pulumi.String("week"),
//								RepeatsCount: pulumi.Int(4),
//								RepeatsOnWeekdays: pulumi.IntArray{
//									pulumi.Int(0),
//									pulumi.Int(1),
//									pulumi.Int(2),
//									pulumi.Int(3),
//								},
//							},
//						},
//					},
//					&rule.V2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: rule.V2TimeslotCustomArray{
//							&rule.V2TimeslotCustomArgs{
//								Repeats:      pulumi.String("month"),
//								RepeatsCount: pulumi.Int(6),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// serviceID:ruleID
//
// ```sh
// $ pulumi import squadcast:suppression/rule/v2:V2 test 62d2fe23a57381088224d726:62da76c088f407f9ca756ca5
// ```
type V2 struct {
	pulumi.CustomResourceState

	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions V2BasicExpressionArrayOutput `pulumi:"basicExpressions"`
	// description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrOutput `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolOutput `pulumi:"isBasic"`
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased pulumi.BoolOutput `pulumi:"isTimebased"`
	// Service id.
	ServiceId pulumi.StringOutput `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots V2TimeslotArrayOutput `pulumi:"timeslots"`
}

// NewV2 registers a new resource with the given unique name, arguments, and options.
func NewV2(ctx *pulumi.Context,
	name string, args *V2Args, opts ...pulumi.ResourceOption) (*V2, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IsBasic == nil {
		return nil, errors.New("invalid value for required argument 'IsBasic'")
	}
	if args.ServiceId == nil {
		return nil, errors.New("invalid value for required argument 'ServiceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource V2
	err := ctx.RegisterResource("squadcast:suppression/rule/v2:V2", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetV2 gets an existing V2 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetV2(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *V2State, opts ...pulumi.ResourceOption) (*V2, error) {
	var resource V2
	err := ctx.ReadResource("squadcast:suppression/rule/v2:V2", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering V2 resources.
type v2State struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions []V2BasicExpression `pulumi:"basicExpressions"`
	// description.
	Description *string `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression *string `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic *bool `pulumi:"isBasic"`
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased *bool `pulumi:"isTimebased"`
	// Service id.
	ServiceId *string `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots []V2Timeslot `pulumi:"timeslots"`
}

type V2State struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions V2BasicExpressionArrayInput
	// description.
	Description pulumi.StringPtrInput
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrInput
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolPtrInput
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased pulumi.BoolPtrInput
	// Service id.
	ServiceId pulumi.StringPtrInput
	// The timeslots for which this rule should be applied.
	Timeslots V2TimeslotArrayInput
}

func (V2State) ElementType() reflect.Type {
	return reflect.TypeOf((*v2State)(nil)).Elem()
}

type v2Args struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions []V2BasicExpression `pulumi:"basicExpressions"`
	// description.
	Description *string `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression *string `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic bool `pulumi:"isBasic"`
	// Service id.
	ServiceId string `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots []V2Timeslot `pulumi:"timeslots"`
}

// The set of arguments for constructing a V2 resource.
type V2Args struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions V2BasicExpressionArrayInput
	// description.
	Description pulumi.StringPtrInput
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrInput
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolInput
	// Service id.
	ServiceId pulumi.StringInput
	// The timeslots for which this rule should be applied.
	Timeslots V2TimeslotArrayInput
}

func (V2Args) ElementType() reflect.Type {
	return reflect.TypeOf((*v2Args)(nil)).Elem()
}

type V2Input interface {
	pulumi.Input

	ToV2Output() V2Output
	ToV2OutputWithContext(ctx context.Context) V2Output
}

func (*V2) ElementType() reflect.Type {
	return reflect.TypeOf((**V2)(nil)).Elem()
}

func (i *V2) ToV2Output() V2Output {
	return i.ToV2OutputWithContext(context.Background())
}

func (i *V2) ToV2OutputWithContext(ctx context.Context) V2Output {
	return pulumi.ToOutputWithContext(ctx, i).(V2Output)
}

// V2ArrayInput is an input type that accepts V2Array and V2ArrayOutput values.
// You can construct a concrete instance of `V2ArrayInput` via:
//
//	V2Array{ V2Args{...} }
type V2ArrayInput interface {
	pulumi.Input

	ToV2ArrayOutput() V2ArrayOutput
	ToV2ArrayOutputWithContext(context.Context) V2ArrayOutput
}

type V2Array []V2Input

func (V2Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*V2)(nil)).Elem()
}

func (i V2Array) ToV2ArrayOutput() V2ArrayOutput {
	return i.ToV2ArrayOutputWithContext(context.Background())
}

func (i V2Array) ToV2ArrayOutputWithContext(ctx context.Context) V2ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(V2ArrayOutput)
}

// V2MapInput is an input type that accepts V2Map and V2MapOutput values.
// You can construct a concrete instance of `V2MapInput` via:
//
//	V2Map{ "key": V2Args{...} }
type V2MapInput interface {
	pulumi.Input

	ToV2MapOutput() V2MapOutput
	ToV2MapOutputWithContext(context.Context) V2MapOutput
}

type V2Map map[string]V2Input

func (V2Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*V2)(nil)).Elem()
}

func (i V2Map) ToV2MapOutput() V2MapOutput {
	return i.ToV2MapOutputWithContext(context.Background())
}

func (i V2Map) ToV2MapOutputWithContext(ctx context.Context) V2MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(V2MapOutput)
}

type V2Output struct{ *pulumi.OutputState }

func (V2Output) ElementType() reflect.Type {
	return reflect.TypeOf((**V2)(nil)).Elem()
}

func (o V2Output) ToV2Output() V2Output {
	return o
}

func (o V2Output) ToV2OutputWithContext(ctx context.Context) V2Output {
	return o
}

// The basic expression which needs to be evaluated to be true for this rule to apply.
func (o V2Output) BasicExpressions() V2BasicExpressionArrayOutput {
	return o.ApplyT(func(v *V2) V2BasicExpressionArrayOutput { return v.BasicExpressions }).(V2BasicExpressionArrayOutput)
}

// description.
func (o V2Output) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *V2) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The expression which needs to be evaluated to be true for this rule to apply.
func (o V2Output) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *V2) pulumi.StringPtrOutput { return v.Expression }).(pulumi.StringPtrOutput)
}

// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
func (o V2Output) IsBasic() pulumi.BoolOutput {
	return o.ApplyT(func(v *V2) pulumi.BoolOutput { return v.IsBasic }).(pulumi.BoolOutput)
}

// is_timebased will be true when users use the time based suppression rule
func (o V2Output) IsTimebased() pulumi.BoolOutput {
	return o.ApplyT(func(v *V2) pulumi.BoolOutput { return v.IsTimebased }).(pulumi.BoolOutput)
}

// Service id.
func (o V2Output) ServiceId() pulumi.StringOutput {
	return o.ApplyT(func(v *V2) pulumi.StringOutput { return v.ServiceId }).(pulumi.StringOutput)
}

// The timeslots for which this rule should be applied.
func (o V2Output) Timeslots() V2TimeslotArrayOutput {
	return o.ApplyT(func(v *V2) V2TimeslotArrayOutput { return v.Timeslots }).(V2TimeslotArrayOutput)
}

type V2ArrayOutput struct{ *pulumi.OutputState }

func (V2ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*V2)(nil)).Elem()
}

func (o V2ArrayOutput) ToV2ArrayOutput() V2ArrayOutput {
	return o
}

func (o V2ArrayOutput) ToV2ArrayOutputWithContext(ctx context.Context) V2ArrayOutput {
	return o
}

func (o V2ArrayOutput) Index(i pulumi.IntInput) V2Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *V2 {
		return vs[0].([]*V2)[vs[1].(int)]
	}).(V2Output)
}

type V2MapOutput struct{ *pulumi.OutputState }

func (V2MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*V2)(nil)).Elem()
}

func (o V2MapOutput) ToV2MapOutput() V2MapOutput {
	return o
}

func (o V2MapOutput) ToV2MapOutputWithContext(ctx context.Context) V2MapOutput {
	return o
}

func (o V2MapOutput) MapIndex(k pulumi.StringInput) V2Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *V2 {
		return vs[0].(map[string]*V2)[vs[1].(string)]
	}).(V2Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*V2Input)(nil)).Elem(), &V2{})
	pulumi.RegisterInputType(reflect.TypeOf((*V2ArrayInput)(nil)).Elem(), V2Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*V2MapInput)(nil)).Elem(), V2Map{})
	pulumi.RegisterOutputType(V2Output{})
	pulumi.RegisterOutputType(V2ArrayOutput{})
	pulumi.RegisterOutputType(V2MapOutput{})
}
