// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package squadcast

import (
	"context"
	"reflect"

	"errors"
	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [Suppression rules](https://support.squadcast.com/docs/alert-suppression) can help you avoid alert fatigue by suppressing notifications for non-actionable alerts.Squadcast will suppress the incidents that match any of the Suppression Rules you create for your Services. These incidents will go into the Suppressed state and you will not get any notifications for them
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/IrisDande/pulumi-squadcast/sdk/go/squadcast"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "exammple team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleService, err := squadcast.LookupService(ctx, &squadcast.LookupServiceArgs{
//				Name:   "example service name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSuppressionRuleV2(ctx, "exampleBasicSuppressionRules", &squadcast.SuppressionRuleV2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(true),
//				Description: pulumi.String("sample basic expression"),
//				BasicExpressions: squadcast.SuppressionRuleV2BasicExpressionArray{
//					&squadcast.SuppressionRuleV2BasicExpressionArgs{
//						Lhs: pulumi.String("abc"),
//						Op:  pulumi.String("is"),
//						Rhs: pulumi.String("xyz"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSuppressionRuleV2(ctx, "exampleSuppressionRules", &squadcast.SuppressionRuleV2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSuppressionRuleV2(ctx, "exampleTimeBasedSuppressionRules", &squadcast.SuppressionRuleV2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//				Timeslots: squadcast.SuppressionRuleV2TimeslotArray{
//					&squadcast.SuppressionRuleV2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("none"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSuppressionRuleV2(ctx, "exampleTimeBasedSuppressionRulesCustomRepetition", &squadcast.SuppressionRuleV2Args{
//				ServiceId:   pulumi.String(exampleService.Id),
//				IsBasic:     pulumi.Bool(false),
//				Description: pulumi.String("not basic"),
//				Expression:  pulumi.String("payload[\"event_id\"] == 40"),
//				Timeslots: squadcast.SuppressionRuleV2TimeslotArray{
//					&squadcast.SuppressionRuleV2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: squadcast.SuppressionRuleV2TimeslotCustomArray{
//							&squadcast.SuppressionRuleV2TimeslotCustomArgs{
//								Repeats:      pulumi.String("day"),
//								RepeatsCount: pulumi.Int(2),
//							},
//						},
//					},
//					&squadcast.SuppressionRuleV2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: squadcast.SuppressionRuleV2TimeslotCustomArray{
//							&squadcast.SuppressionRuleV2TimeslotCustomArgs{
//								Repeats:      pulumi.String("week"),
//								RepeatsCount: pulumi.Int(4),
//								RepeatsOnWeekdays: pulumi.IntArray{
//									pulumi.Int(0),
//									pulumi.Int(1),
//									pulumi.Int(2),
//									pulumi.Int(3),
//								},
//							},
//						},
//					},
//					&squadcast.SuppressionRuleV2TimeslotArgs{
//						TimeZone:   pulumi.String("Asia/Calcutta"),
//						StartTime:  pulumi.String("2022-04-08T06:22:14.975Z"),
//						EndTime:    pulumi.String("2022-04-28T06:22:14.975Z"),
//						EndsOn:     pulumi.String("2022-04-28T06:22:14.975Z"),
//						Repetition: pulumi.String("custom"),
//						IsAllday:   pulumi.Bool(false),
//						EndsNever:  pulumi.Bool(true),
//						Customs: squadcast.SuppressionRuleV2TimeslotCustomArray{
//							&squadcast.SuppressionRuleV2TimeslotCustomArgs{
//								Repeats:      pulumi.String("month"),
//								RepeatsCount: pulumi.Int(6),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// serviceID:ruleID
//
// ```sh
// $ pulumi import squadcast:index/suppressionRuleV2:SuppressionRuleV2 test 62d2fe23a57381088224d726:62da76c088f407f9ca756ca5
// ```
type SuppressionRuleV2 struct {
	pulumi.CustomResourceState

	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions SuppressionRuleV2BasicExpressionArrayOutput `pulumi:"basicExpressions"`
	// description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrOutput `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolOutput `pulumi:"isBasic"`
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased pulumi.BoolOutput `pulumi:"isTimebased"`
	// Service id.
	ServiceId pulumi.StringOutput `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots SuppressionRuleV2TimeslotArrayOutput `pulumi:"timeslots"`
}

// NewSuppressionRuleV2 registers a new resource with the given unique name, arguments, and options.
func NewSuppressionRuleV2(ctx *pulumi.Context,
	name string, args *SuppressionRuleV2Args, opts ...pulumi.ResourceOption) (*SuppressionRuleV2, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IsBasic == nil {
		return nil, errors.New("invalid value for required argument 'IsBasic'")
	}
	if args.ServiceId == nil {
		return nil, errors.New("invalid value for required argument 'ServiceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SuppressionRuleV2
	err := ctx.RegisterResource("squadcast:index/suppressionRuleV2:SuppressionRuleV2", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSuppressionRuleV2 gets an existing SuppressionRuleV2 resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSuppressionRuleV2(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SuppressionRuleV2State, opts ...pulumi.ResourceOption) (*SuppressionRuleV2, error) {
	var resource SuppressionRuleV2
	err := ctx.ReadResource("squadcast:index/suppressionRuleV2:SuppressionRuleV2", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SuppressionRuleV2 resources.
type suppressionRuleV2State struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions []SuppressionRuleV2BasicExpression `pulumi:"basicExpressions"`
	// description.
	Description *string `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression *string `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic *bool `pulumi:"isBasic"`
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased *bool `pulumi:"isTimebased"`
	// Service id.
	ServiceId *string `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots []SuppressionRuleV2Timeslot `pulumi:"timeslots"`
}

type SuppressionRuleV2State struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions SuppressionRuleV2BasicExpressionArrayInput
	// description.
	Description pulumi.StringPtrInput
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrInput
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolPtrInput
	// is_timebased will be true when users use the time based suppression rule
	IsTimebased pulumi.BoolPtrInput
	// Service id.
	ServiceId pulumi.StringPtrInput
	// The timeslots for which this rule should be applied.
	Timeslots SuppressionRuleV2TimeslotArrayInput
}

func (SuppressionRuleV2State) ElementType() reflect.Type {
	return reflect.TypeOf((*suppressionRuleV2State)(nil)).Elem()
}

type suppressionRuleV2Args struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions []SuppressionRuleV2BasicExpression `pulumi:"basicExpressions"`
	// description.
	Description *string `pulumi:"description"`
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression *string `pulumi:"expression"`
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic bool `pulumi:"isBasic"`
	// Service id.
	ServiceId string `pulumi:"serviceId"`
	// The timeslots for which this rule should be applied.
	Timeslots []SuppressionRuleV2Timeslot `pulumi:"timeslots"`
}

// The set of arguments for constructing a SuppressionRuleV2 resource.
type SuppressionRuleV2Args struct {
	// The basic expression which needs to be evaluated to be true for this rule to apply.
	BasicExpressions SuppressionRuleV2BasicExpressionArrayInput
	// description.
	Description pulumi.StringPtrInput
	// The expression which needs to be evaluated to be true for this rule to apply.
	Expression pulumi.StringPtrInput
	// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
	IsBasic pulumi.BoolInput
	// Service id.
	ServiceId pulumi.StringInput
	// The timeslots for which this rule should be applied.
	Timeslots SuppressionRuleV2TimeslotArrayInput
}

func (SuppressionRuleV2Args) ElementType() reflect.Type {
	return reflect.TypeOf((*suppressionRuleV2Args)(nil)).Elem()
}

type SuppressionRuleV2Input interface {
	pulumi.Input

	ToSuppressionRuleV2Output() SuppressionRuleV2Output
	ToSuppressionRuleV2OutputWithContext(ctx context.Context) SuppressionRuleV2Output
}

func (*SuppressionRuleV2) ElementType() reflect.Type {
	return reflect.TypeOf((**SuppressionRuleV2)(nil)).Elem()
}

func (i *SuppressionRuleV2) ToSuppressionRuleV2Output() SuppressionRuleV2Output {
	return i.ToSuppressionRuleV2OutputWithContext(context.Background())
}

func (i *SuppressionRuleV2) ToSuppressionRuleV2OutputWithContext(ctx context.Context) SuppressionRuleV2Output {
	return pulumi.ToOutputWithContext(ctx, i).(SuppressionRuleV2Output)
}

// SuppressionRuleV2ArrayInput is an input type that accepts SuppressionRuleV2Array and SuppressionRuleV2ArrayOutput values.
// You can construct a concrete instance of `SuppressionRuleV2ArrayInput` via:
//
//	SuppressionRuleV2Array{ SuppressionRuleV2Args{...} }
type SuppressionRuleV2ArrayInput interface {
	pulumi.Input

	ToSuppressionRuleV2ArrayOutput() SuppressionRuleV2ArrayOutput
	ToSuppressionRuleV2ArrayOutputWithContext(context.Context) SuppressionRuleV2ArrayOutput
}

type SuppressionRuleV2Array []SuppressionRuleV2Input

func (SuppressionRuleV2Array) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SuppressionRuleV2)(nil)).Elem()
}

func (i SuppressionRuleV2Array) ToSuppressionRuleV2ArrayOutput() SuppressionRuleV2ArrayOutput {
	return i.ToSuppressionRuleV2ArrayOutputWithContext(context.Background())
}

func (i SuppressionRuleV2Array) ToSuppressionRuleV2ArrayOutputWithContext(ctx context.Context) SuppressionRuleV2ArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SuppressionRuleV2ArrayOutput)
}

// SuppressionRuleV2MapInput is an input type that accepts SuppressionRuleV2Map and SuppressionRuleV2MapOutput values.
// You can construct a concrete instance of `SuppressionRuleV2MapInput` via:
//
//	SuppressionRuleV2Map{ "key": SuppressionRuleV2Args{...} }
type SuppressionRuleV2MapInput interface {
	pulumi.Input

	ToSuppressionRuleV2MapOutput() SuppressionRuleV2MapOutput
	ToSuppressionRuleV2MapOutputWithContext(context.Context) SuppressionRuleV2MapOutput
}

type SuppressionRuleV2Map map[string]SuppressionRuleV2Input

func (SuppressionRuleV2Map) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SuppressionRuleV2)(nil)).Elem()
}

func (i SuppressionRuleV2Map) ToSuppressionRuleV2MapOutput() SuppressionRuleV2MapOutput {
	return i.ToSuppressionRuleV2MapOutputWithContext(context.Background())
}

func (i SuppressionRuleV2Map) ToSuppressionRuleV2MapOutputWithContext(ctx context.Context) SuppressionRuleV2MapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SuppressionRuleV2MapOutput)
}

type SuppressionRuleV2Output struct{ *pulumi.OutputState }

func (SuppressionRuleV2Output) ElementType() reflect.Type {
	return reflect.TypeOf((**SuppressionRuleV2)(nil)).Elem()
}

func (o SuppressionRuleV2Output) ToSuppressionRuleV2Output() SuppressionRuleV2Output {
	return o
}

func (o SuppressionRuleV2Output) ToSuppressionRuleV2OutputWithContext(ctx context.Context) SuppressionRuleV2Output {
	return o
}

// The basic expression which needs to be evaluated to be true for this rule to apply.
func (o SuppressionRuleV2Output) BasicExpressions() SuppressionRuleV2BasicExpressionArrayOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) SuppressionRuleV2BasicExpressionArrayOutput { return v.BasicExpressions }).(SuppressionRuleV2BasicExpressionArrayOutput)
}

// description.
func (o SuppressionRuleV2Output) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The expression which needs to be evaluated to be true for this rule to apply.
func (o SuppressionRuleV2Output) Expression() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) pulumi.StringPtrOutput { return v.Expression }).(pulumi.StringPtrOutput)
}

// is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
func (o SuppressionRuleV2Output) IsBasic() pulumi.BoolOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) pulumi.BoolOutput { return v.IsBasic }).(pulumi.BoolOutput)
}

// is_timebased will be true when users use the time based suppression rule
func (o SuppressionRuleV2Output) IsTimebased() pulumi.BoolOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) pulumi.BoolOutput { return v.IsTimebased }).(pulumi.BoolOutput)
}

// Service id.
func (o SuppressionRuleV2Output) ServiceId() pulumi.StringOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) pulumi.StringOutput { return v.ServiceId }).(pulumi.StringOutput)
}

// The timeslots for which this rule should be applied.
func (o SuppressionRuleV2Output) Timeslots() SuppressionRuleV2TimeslotArrayOutput {
	return o.ApplyT(func(v *SuppressionRuleV2) SuppressionRuleV2TimeslotArrayOutput { return v.Timeslots }).(SuppressionRuleV2TimeslotArrayOutput)
}

type SuppressionRuleV2ArrayOutput struct{ *pulumi.OutputState }

func (SuppressionRuleV2ArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SuppressionRuleV2)(nil)).Elem()
}

func (o SuppressionRuleV2ArrayOutput) ToSuppressionRuleV2ArrayOutput() SuppressionRuleV2ArrayOutput {
	return o
}

func (o SuppressionRuleV2ArrayOutput) ToSuppressionRuleV2ArrayOutputWithContext(ctx context.Context) SuppressionRuleV2ArrayOutput {
	return o
}

func (o SuppressionRuleV2ArrayOutput) Index(i pulumi.IntInput) SuppressionRuleV2Output {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SuppressionRuleV2 {
		return vs[0].([]*SuppressionRuleV2)[vs[1].(int)]
	}).(SuppressionRuleV2Output)
}

type SuppressionRuleV2MapOutput struct{ *pulumi.OutputState }

func (SuppressionRuleV2MapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SuppressionRuleV2)(nil)).Elem()
}

func (o SuppressionRuleV2MapOutput) ToSuppressionRuleV2MapOutput() SuppressionRuleV2MapOutput {
	return o
}

func (o SuppressionRuleV2MapOutput) ToSuppressionRuleV2MapOutputWithContext(ctx context.Context) SuppressionRuleV2MapOutput {
	return o
}

func (o SuppressionRuleV2MapOutput) MapIndex(k pulumi.StringInput) SuppressionRuleV2Output {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SuppressionRuleV2 {
		return vs[0].(map[string]*SuppressionRuleV2)[vs[1].(string)]
	}).(SuppressionRuleV2Output)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SuppressionRuleV2Input)(nil)).Elem(), &SuppressionRuleV2{})
	pulumi.RegisterInputType(reflect.TypeOf((*SuppressionRuleV2ArrayInput)(nil)).Elem(), SuppressionRuleV2Array{})
	pulumi.RegisterInputType(reflect.TypeOf((*SuppressionRuleV2MapInput)(nil)).Elem(), SuppressionRuleV2Map{})
	pulumi.RegisterOutputType(SuppressionRuleV2Output{})
	pulumi.RegisterOutputType(SuppressionRuleV2ArrayOutput{})
	pulumi.RegisterOutputType(SuppressionRuleV2MapOutput{})
}
