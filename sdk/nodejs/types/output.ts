// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DeduplicationRuleV2BasicExpression {
    /**
     * left hand side dropdown value
     */
    lhs: string;
    /**
     * operator (is, is*not, matches, not*contains)
     */
    op: string;
    /**
     * right hand side value
     */
    rhs: string;
}

export interface EscalationPolicyEntityOwner {
    /**
     * Escalation policy owner id.
     */
    id: string;
    /**
     * Escalation policy owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface EscalationPolicyRepeat {
    /**
     * The number of minutes to wait before repeating the escalation policy
     */
    delayMinutes: number;
    /**
     * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
     */
    times: number;
}

export interface EscalationPolicyRule {
    delayMinutes: number;
    /**
     * Notification channels to notify the targets. (SMS, Phone, Email, Push)
     */
    notificationChannels?: string[];
    /**
     * repeat this rule
     */
    repeat?: outputs.EscalationPolicyRuleRepeat;
    roundRobin?: outputs.EscalationPolicyRuleRoundRobin;
    targets: outputs.EscalationPolicyRuleTarget[];
}

export interface EscalationPolicyRuleRepeat {
    /**
     * repeat after minutes
     */
    delayMinutes: number;
    /**
     * repeat times
     */
    times: number;
}

export interface EscalationPolicyRuleRoundRobin {
    /**
     * Enables Round Robin escalation within this layer
     */
    enabled: boolean;
    rotation?: outputs.EscalationPolicyRuleRoundRobinRotation;
}

export interface EscalationPolicyRuleRoundRobinRotation {
    /**
     * repeat after minutes
     */
    delayMinutes?: number;
    /**
     * enable rotation within
     */
    enabled?: boolean;
}

export interface EscalationPolicyRuleTarget {
    /**
     * ID of the target
     */
    id: string;
    /**
     * Type of the target. (user, squad, schedule, schedulev2)
     */
    type: string;
}

export interface GerEntityOwner {
    /**
     * GER owner id.
     */
    id: string;
    /**
     * GER owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface GetEscalationPolicyEntityOwner {
    /**
     * Escalation policy owner id.
     */
    id: string;
    /**
     * Escalation policy owner type. (user or squad or team)
     */
    type: string;
}

export interface GetEscalationPolicyRepeat {
    /**
     * The number of minutes to wait before repeating the escalation policy
     */
    delayMinutes: number;
    /**
     * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
     */
    times: number;
}

export interface GetEscalationPolicyRule {
    delayMinutes: number;
    notificationChannels: string[];
    /**
     * repeat this rule
     */
    repeats: outputs.GetEscalationPolicyRuleRepeat[];
    roundRobins: outputs.GetEscalationPolicyRuleRoundRobin[];
    targets: outputs.GetEscalationPolicyRuleTarget[];
}

export interface GetEscalationPolicyRuleRepeat {
    /**
     * repeat after minutes
     */
    delayMinutes: number;
    /**
     * repeat times
     */
    times: number;
}

export interface GetEscalationPolicyRuleRoundRobin {
    /**
     * Round Robin Escalation is an incident assignment strategy where users are placed in a ring and assigned to incidents sequentially. This strategy can help ensure that incidents are equitably distributed. It can also lower incident response time if a service experiences concurrent incidents, since the incidents will not all be assigned to the same responder.
     */
    enabled: boolean;
    rotations: outputs.GetEscalationPolicyRuleRoundRobinRotation[];
}

export interface GetEscalationPolicyRuleRoundRobinRotation {
    /**
     * repeat after minutes
     */
    delayMinutes: number;
    /**
     * enable rotation within
     */
    enabled: boolean;
}

export interface GetEscalationPolicyRuleTarget {
    id: string;
    type: string;
}

export interface GetRunbookEntityOwner {
    /**
     * Runbook owner id.
     */
    id: string;
    /**
     * Runbook owner type. (user or squad or team)
     */
    type: string;
}

export interface GetRunbookStep {
    content: string;
}

export interface GetScheduleV2EntityOwner {
    /**
     * Schedule owner id.
     */
    id: string;
    /**
     * Schedule owner type (user, team, squad).
     */
    type: string;
}

export interface GetScheduleV2Tag {
    /**
     * Schedule tag color.
     */
    color: string;
    /**
     * Schedule tag key.
     */
    key: string;
    /**
     * Schedule tag value.
     */
    value: string;
}

export interface GetServiceMaintainer {
    /**
     * The id of the maintainer.
     */
    id: string;
    /**
     * The type of the maintainer. (user, team or squad)
     */
    type: string;
}

export interface GetServiceTag {
    /**
     * key
     */
    key: string;
    /**
     * value
     */
    value: string;
}

export interface GetTeamMember {
    roleIds: string[];
    /**
     * User id.
     */
    userId: string;
}

export interface GetTeamRole {
    abilities: string[];
    /**
     * Role is default.
     */
    default: boolean;
    /**
     * Role id.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
}

export interface GetUserNotificationRule {
    /**
     * notification rule delay_minutes, (to be deprecated).
     */
    delayMinutes: number;
    /**
     * Personal notification rule type.
     */
    type: string;
}

export interface GetUserOncallReminderRule {
    /**
     * oncall reminder rule delay_minutes.
     */
    delayMinutes: number;
    /**
     * oncall reminder rule type.
     */
    type: string;
}

export interface GetWebformInputField {
    /**
     * Input field Label.
     */
    label: string;
    /**
     * Input field options.
     */
    options: string[];
}

export interface GetWebformOwner {
    /**
     * Form owner id.
     */
    id: string;
    /**
     * Form owner name.
     */
    name: string;
    /**
     * Form owner type (user, team, squad).
     */
    type: string;
}

export interface GetWebformService {
    /**
     * Service alias.
     */
    alias: string;
    /**
     * Service name.
     */
    name: string;
    /**
     * Service ID.
     */
    serviceId: string;
}

export interface GetWebformSeverity {
    /**
     * Severity description.
     */
    description: string;
    /**
     * Severity type.
     */
    type: string;
}

export interface RoutingRuleV2BasicExpression {
    /**
     * left hand side dropdown value
     */
    lhs: string;
    /**
     * right hand side value
     */
    rhs: string;
}

export interface RunbookEntityOwner {
    /**
     * Runbook owner id.
     */
    id: string;
    /**
     * Runbook owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface RunbookStep {
    content: string;
}

export interface ScheduleRotationV2ParticipantGroup {
    /**
     * Group participants.
     */
    participants?: outputs.ScheduleRotationV2ParticipantGroupParticipant[];
}

export interface ScheduleRotationV2ParticipantGroupParticipant {
    /**
     * Participant id.
     */
    id: string;
    /**
     * Participant type (user, team, squad).
     */
    type: string;
}

export interface ScheduleRotationV2ShiftTimeslot {
    /**
     * Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
     */
    dayOfWeek?: string;
    /**
     * Defines the duration of each shift. (in minutes)
     */
    duration: number;
    /**
     * Defines the start hour of the each shift in the schedule timezone.
     */
    startHour: number;
    /**
     * Defines the start minute of the each shift in the schedule timezone.
     */
    startMinute: number;
}

export interface ScheduleV2EntityOwner {
    /**
     * Schedule owner id.
     */
    id: string;
    /**
     * Schedule owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface ScheduleV2Tag {
    /**
     * Schedule tag color.
     */
    color: string;
    /**
     * Schedule tag key.
     */
    key: string;
    /**
     * Schedule tag value.
     */
    value: string;
}

export interface ServiceMaintainer {
    /**
     * The id of the maintainer.
     */
    id: string;
    /**
     * The type of the maintainer. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface ServiceMaintenanceWindow {
    /**
     * Starting Time
     */
    from: string;
    /**
     * repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
     */
    repeatFrequency?: string;
    /**
     * Till when you want to repeat this Maintenance mode
     */
    repeatTill?: string;
    /**
     * End Time.
     */
    till: string;
}

export interface ServiceTag {
    /**
     * key
     */
    key: string;
    /**
     * value
     */
    value: string;
}

export interface SloEntityOwner {
    /**
     * SLO owner id.
     */
    id: string;
    /**
     * SLO owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface SloNotify {
    /**
     * The ID of the notification rule
     */
    id: number;
    /**
     * The ID of the service in which the user want to create an incident
     */
    serviceId?: string;
    /**
     * The ID of the SLO.
     */
    sloId: number;
    /**
     * List of Squad ID's who should be alerted via email.
     */
    squadIds?: string[];
    /**
     * List of user ID's who should be alerted via email.
     */
    userIds?: string[];
}

export interface SloRule {
    /**
     * The ID of the monitoring rule
     */
    id: number;
    /**
     * Is checked?
     */
    isChecked: boolean;
    /**
     * The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
     */
    name: string;
    /**
     * The ID of the SLO
     */
    sloId: number;
    /**
     * Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
     */
    threshold?: number;
}

export interface StatusPageOwner {
    /**
     * Status page owner id.
     */
    id: string;
    /**
     * Status page owner type Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface StatusPageThemeColor {
    /**
     * Primary color.
     */
    primary: string;
    /**
     * Secondary color.
     */
    secondary: string;
}

export interface SuppressionRuleV2BasicExpression {
    /**
     * left hand side dropdown value
     */
    lhs: string;
    /**
     * operator (is, is*not, matches, not*contains)
     */
    op: string;
    /**
     * right hand side value
     */
    rhs: string;
}

export interface SuppressionRuleV2Timeslot {
    /**
     * Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
     */
    customs?: outputs.SuppressionRuleV2TimeslotCustom[];
    /**
     * Defines the end date of the time slot
     */
    endTime: string;
    /**
     * Defines whether the time slot ends or not
     */
    endsNever?: boolean;
    /**
     * Defines the end date of the repetition
     */
    endsOn: string;
    /**
     * Defines if the time slot is an all day slot
     */
    isAllday?: boolean;
    /**
     * Defines whether repetition is custom or not
     */
    isCustom: boolean;
    /**
     * Defines the repetition of the time slot
     */
    repetition: string;
    /**
     * Defines the start date of the time slot
     */
    startTime: string;
    /**
     * Time zone for the time slot
     */
    timeZone: string;
}

export interface SuppressionRuleV2TimeslotCustom {
    /**
     * Determines how often the rule repeats. Valid values are day, week, month.
     */
    repeats: string;
    /**
     * Number of times to repeat.
     */
    repeatsCount?: number;
    /**
     * Repeats on month.
     */
    repeatsOnMonth: string;
    /**
     * List of weekdays to repeat on.
     */
    repeatsOnWeekdays?: number[];
}

export interface TaggingRuleV2BasicExpression {
    /**
     * left hand side dropdown value
     */
    lhs: string;
    /**
     * operator (is, is*not, matches, not*contains)
     */
    op: string;
    /**
     * right hand side value
     */
    rhs: string;
}

export interface TaggingRuleV2Tag {
    /**
     * Tag color, hex values
     */
    color: string;
    /**
     * key
     */
    key: string;
    /**
     * value
     */
    value: string;
}

export interface WebformInputField {
    /**
     * Input field Label.
     */
    label?: string;
    /**
     * Input field options.
     */
    options?: string[];
}

export interface WebformOwner {
    /**
     * Form owner id.
     */
    id: string;
    /**
     * Form owner name.
     */
    name: string;
    /**
     * Form owner type Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface WebformService {
    /**
     * Service alias.
     */
    alias?: string;
    /**
     * Service name.
     */
    name: string;
    /**
     * Service ID.
     */
    serviceId: string;
}

export interface WebformSeverity {
    /**
     * Severity description.
     */
    description?: string;
    /**
     * Severity type.
     */
    type: string;
}

export interface WorkflowActionChannel {
    /**
     * The display text of the communication channel
     */
    displayText: string;
    /**
     * The link of the communication channel
     */
    link: string;
    /**
     * The type of the communication channel
     */
    type: string;
}

export interface WorkflowActionComponentAndImpact {
    /**
     * The ID of the component
     */
    componentId: number;
    /**
     * The ID of the impact status
     */
    impactStatusId: number;
}

export interface WorkflowActionHeader {
    /**
     * The key of the header
     */
    key: string;
    /**
     * The value of the header
     */
    value: string;
}

export interface WorkflowActionStatusAndMessage {
    /**
     * The messages to be set for the issue
     */
    messages?: string[];
    /**
     * The ID of the status
     */
    statusId: number;
}

export interface WorkflowEntityOwner {
    /**
     * The ID of this resource.
     */
    id: string;
    type: string;
}

export interface WorkflowFilters {
    /**
     * Condition to be applied on the filters (and / or)
     */
    condition: string;
    filters?: outputs.WorkflowFiltersFilter[];
}

export interface WorkflowFiltersFilter {
    /**
     * Condition to be applied on the filters (and / or)
     */
    condition?: string;
    filters?: outputs.WorkflowFiltersFilterFilter[];
    type?: string;
    value?: string;
}

export interface WorkflowFiltersFilterFilter {
    key?: string;
    type?: string;
    value?: string;
}

export interface WorkflowTag {
    color: string;
    key: string;
    value: string;
}

export namespace deduplication {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.deduplication.RulesRuleBasicExpression[];
        /**
         * Denotes if dependent services should also be deduplicated
         */
        dependencyDeduplication?: boolean;
        /**
         * description.
         */
        description?: string;
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * time unit (mins or hours)
         */
        timeUnit?: string;
        /**
         * integer for time_unit
         */
        timeWindow?: number;
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

}

export namespace routing {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.routing.RulesRuleBasicExpression[];
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * The id of the entity (user, escalation policy, squad) for which we are routing this incident.
         */
        routeToId: string;
        /**
         * Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
         */
        routeToType: string;
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

}

export namespace suppression {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.suppression.RulesRuleBasicExpression[];
        /**
         * description.
         */
        description?: string;
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * is_timebased will be true when users use the time based suppression rule
         */
        isTimebased: boolean;
        /**
         * The timeslots for which this rule should be applied.
         */
        timeslots?: outputs.suppression.RulesRuleTimeslot[];
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export interface RulesRuleTimeslot {
        /**
         * Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
         */
        customs?: outputs.suppression.RulesRuleTimeslotCustom[];
        /**
         * Defines the end date of the time slot
         */
        endTime: string;
        /**
         * Defines whether the time slot ends or not
         */
        endsNever?: boolean;
        /**
         * Defines the end date of the repetition
         */
        endsOn: string;
        /**
         * Defines if the time slot is an all day slot
         */
        isAllday?: boolean;
        /**
         * Defines whether repetition is custom or not
         */
        isCustom: boolean;
        /**
         * Defines the repetition of the time slot
         */
        repetition: string;
        /**
         * Defines the start date of the time slot
         */
        startTime: string;
        /**
         * Time zone for the time slot
         */
        timeZone: string;
    }

    export interface RulesRuleTimeslotCustom {
        /**
         * Determines how often the rule repeats. Valid values are day, week, month.
         */
        repeats: string;
        /**
         * Number of times to repeat.
         */
        repeatsCount?: number;
        /**
         * Repeats on month.
         */
        repeatsOnMonth: string;
        /**
         * List of weekdays to repeat on.
         */
        repeatsOnWeekdays?: number[];
    }

}

export namespace tagging {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.tagging.RulesRuleBasicExpression[];
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
         */
        tags?: outputs.tagging.RulesRuleTag[];
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export interface RulesRuleTag {
        /**
         * Tag color, hex values
         */
        color: string;
        /**
         * key
         */
        key: string;
        /**
         * value
         */
        value: string;
    }

}
