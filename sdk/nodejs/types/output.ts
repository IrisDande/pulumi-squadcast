// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GerEntityOwner {
    /**
     * GER owner id.
     */
    id: string;
    /**
     * GER owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface GetRunbookEntityOwner {
    /**
     * Runbook owner id.
     */
    id: string;
    /**
     * Runbook owner type. (user or squad or team)
     */
    type: string;
}

export interface GetRunbookStep {
    content: string;
}

export interface GetServiceMaintainer {
    /**
     * The id of the maintainer.
     */
    id: string;
    /**
     * The type of the maintainer. (user, team or squad)
     */
    type: string;
}

export interface GetServiceTag {
    /**
     * key
     */
    key: string;
    /**
     * value
     */
    value: string;
}

export interface GetTeamMember {
    roleIds: string[];
    /**
     * User id.
     */
    userId: string;
}

export interface GetTeamRole {
    abilities: string[];
    /**
     * Role is default.
     */
    default: boolean;
    /**
     * Role id.
     */
    id: string;
    /**
     * Role name.
     */
    name: string;
}

export interface GetUserNotificationRule {
    /**
     * notification rule delay_minutes, (to be deprecated).
     */
    delayMinutes: number;
    /**
     * Personal notification rule type.
     */
    type: string;
}

export interface GetUserOncallReminderRule {
    /**
     * oncall reminder rule delay_minutes.
     */
    delayMinutes: number;
    /**
     * oncall reminder rule type.
     */
    type: string;
}

export interface GetWebformInputField {
    /**
     * Input field Label.
     */
    label: string;
    /**
     * Input field options.
     */
    options: string[];
}

export interface GetWebformOwner {
    /**
     * Form owner id.
     */
    id: string;
    /**
     * Form owner name.
     */
    name: string;
    /**
     * Form owner type (user, team, squad).
     */
    type: string;
}

export interface GetWebformService {
    /**
     * Service alias.
     */
    alias: string;
    /**
     * Service name.
     */
    name: string;
    /**
     * Service ID.
     */
    serviceId: string;
}

export interface GetWebformSeverity {
    /**
     * Severity description.
     */
    description: string;
    /**
     * Severity type.
     */
    type: string;
}

export interface RunbookEntityOwner {
    /**
     * Runbook owner id.
     */
    id: string;
    /**
     * Runbook owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface RunbookStep {
    content: string;
}

export interface ServiceMaintainer {
    /**
     * The id of the maintainer.
     */
    id: string;
    /**
     * The type of the maintainer. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface ServiceTag {
    /**
     * key
     */
    key: string;
    /**
     * value
     */
    value: string;
}

export interface SloEntityOwner {
    /**
     * SLO owner id.
     */
    id: string;
    /**
     * SLO owner type. Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface SloNotify {
    /**
     * The ID of the notification rule
     */
    id: number;
    /**
     * The ID of the service in which the user want to create an incident
     */
    serviceId?: string;
    /**
     * The ID of the SLO.
     */
    sloId: number;
    /**
     * List of Squad ID's who should be alerted via email.
     */
    squadIds?: string[];
    /**
     * List of user ID's who should be alerted via email.
     */
    userIds?: string[];
}

export interface SloRule {
    /**
     * The ID of the monitoring rule
     */
    id: number;
    /**
     * Is checked?
     */
    isChecked: boolean;
    /**
     * The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
     */
    name: string;
    /**
     * The ID of the SLO
     */
    sloId: number;
    /**
     * Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
     */
    threshold?: number;
}

export interface WebformInputField {
    /**
     * Input field Label.
     */
    label?: string;
    /**
     * Input field options.
     */
    options?: string[];
}

export interface WebformOwner {
    /**
     * Form owner id.
     */
    id: string;
    /**
     * Form owner name.
     */
    name: string;
    /**
     * Form owner type Supported values are 'user' or 'squad'.
     */
    type: string;
}

export interface WebformService {
    /**
     * Service alias.
     */
    alias?: string;
    /**
     * Service name.
     */
    name: string;
    /**
     * Service ID.
     */
    serviceId: string;
}

export interface WebformSeverity {
    /**
     * Severity description.
     */
    description?: string;
    /**
     * Severity type.
     */
    type: string;
}

export interface WorkflowEntityOwner {
    /**
     * The ID of this resource.
     */
    id: string;
    type: string;
}

export interface WorkflowFilters {
    /**
     * Condition to be applied on the filters (and / or)
     */
    condition: string;
    filters?: outputs.WorkflowFiltersFilter[];
}

export interface WorkflowFiltersFilter {
    /**
     * Condition to be applied on the filters (and / or)
     */
    condition?: string;
    filters?: outputs.WorkflowFiltersFilterFilter[];
    type?: string;
    value?: string;
}

export interface WorkflowFiltersFilterFilter {
    key?: string;
    type?: string;
    value?: string;
}

export interface WorkflowTag {
    color: string;
    key: string;
    value: string;
}

export namespace deduplication {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.deduplication.RulesRuleBasicExpression[];
        /**
         * Denotes if dependent services should also be deduplicated
         */
        dependencyDeduplication?: boolean;
        /**
         * description.
         */
        description?: string;
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * time unit (mins or hours)
         */
        timeUnit?: string;
        /**
         * integer for time_unit
         */
        timeWindow?: number;
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export namespace rule {
        export interface V2BasicExpression {
            /**
             * left hand side dropdown value
             */
            lhs: string;
            /**
             * operator (is, is*not, matches, not*contains)
             */
            op: string;
            /**
             * right hand side value
             */
            rhs: string;
        }

    }
}

export namespace escalation {
    export interface GetPolicyEntityOwner {
        /**
         * Escalation policy owner id.
         */
        id: string;
        /**
         * Escalation policy owner type. (user or squad or team)
         */
        type: string;
    }

    export interface GetPolicyRepeat {
        /**
         * The number of minutes to wait before repeating the escalation policy
         */
        delayMinutes: number;
        /**
         * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
         */
        times: number;
    }

    export interface GetPolicyRule {
        delayMinutes: number;
        notificationChannels: string[];
        /**
         * repeat this rule
         */
        repeats: outputs.escalation.GetPolicyRuleRepeat[];
        roundRobins: outputs.escalation.GetPolicyRuleRoundRobin[];
        targets: outputs.escalation.GetPolicyRuleTarget[];
    }

    export interface GetPolicyRuleRepeat {
        /**
         * repeat after minutes
         */
        delayMinutes: number;
        /**
         * repeat times
         */
        times: number;
    }

    export interface GetPolicyRuleRoundRobin {
        /**
         * Round Robin Escalation is an incident assignment strategy where users are placed in a ring and assigned to incidents sequentially. This strategy can help ensure that incidents are equitably distributed. It can also lower incident response time if a service experiences concurrent incidents, since the incidents will not all be assigned to the same responder.
         */
        enabled: boolean;
        rotations: outputs.escalation.GetPolicyRuleRoundRobinRotation[];
    }

    export interface GetPolicyRuleRoundRobinRotation {
        /**
         * repeat after minutes
         */
        delayMinutes: number;
        /**
         * enable rotation within
         */
        enabled: boolean;
    }

    export interface GetPolicyRuleTarget {
        id: string;
        type: string;
    }

    export interface PolicyEntityOwner {
        /**
         * Escalation policy owner id.
         */
        id: string;
        /**
         * Escalation policy owner type. Supported values are 'user' or 'squad'.
         */
        type: string;
    }

    export interface PolicyRepeat {
        /**
         * The number of minutes to wait before repeating the escalation policy
         */
        delayMinutes: number;
        /**
         * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
         */
        times: number;
    }

    export interface PolicyRule {
        delayMinutes: number;
        /**
         * Notification channels to notify the targets. (SMS, Phone, Email, Push)
         */
        notificationChannels?: string[];
        /**
         * repeat this rule
         */
        repeat?: outputs.escalation.PolicyRuleRepeat;
        roundRobin?: outputs.escalation.PolicyRuleRoundRobin;
        targets: outputs.escalation.PolicyRuleTarget[];
    }

    export interface PolicyRuleRepeat {
        /**
         * repeat after minutes
         */
        delayMinutes: number;
        /**
         * repeat times
         */
        times: number;
    }

    export interface PolicyRuleRoundRobin {
        /**
         * Enables Round Robin escalation within this layer
         */
        enabled: boolean;
        rotation?: outputs.escalation.PolicyRuleRoundRobinRotation;
    }

    export interface PolicyRuleRoundRobinRotation {
        /**
         * repeat after minutes
         */
        delayMinutes?: number;
        /**
         * enable rotation within
         */
        enabled?: boolean;
    }

    export interface PolicyRuleTarget {
        /**
         * ID of the target
         */
        id: string;
        /**
         * Type of the target. (user, squad, schedule, schedulev2)
         */
        type: string;
    }

}

export namespace routing {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.routing.RulesRuleBasicExpression[];
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * The id of the entity (user, escalation policy, squad) for which we are routing this incident.
         */
        routeToId: string;
        /**
         * Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
         */
        routeToType: string;
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export namespace rule {
        export interface V2BasicExpression {
            /**
             * left hand side dropdown value
             */
            lhs: string;
            /**
             * right hand side value
             */
            rhs: string;
        }

    }
}

export namespace schedule {
    export interface GetV2EntityOwner {
        /**
         * Schedule owner id.
         */
        id: string;
        /**
         * Schedule owner type (user, team, squad).
         */
        type: string;
    }

    export interface GetV2Tag {
        /**
         * Schedule tag color.
         */
        color: string;
        /**
         * Schedule tag key.
         */
        key: string;
        /**
         * Schedule tag value.
         */
        value: string;
    }

    export interface V2EntityOwner {
        /**
         * Schedule owner id.
         */
        id: string;
        /**
         * Schedule owner type. Supported values are 'user' or 'squad'.
         */
        type: string;
    }

    export interface V2Tag {
        /**
         * Schedule tag color.
         */
        color: string;
        /**
         * Schedule tag key.
         */
        key: string;
        /**
         * Schedule tag value.
         */
        value: string;
    }

    export namespace rotation {
        export interface V2ParticipantGroup {
            /**
             * Group participants.
             */
            participants?: outputs.schedule.rotation.V2ParticipantGroupParticipant[];
        }

        export interface V2ParticipantGroupParticipant {
            /**
             * Participant id.
             */
            id: string;
            /**
             * Participant type (user, team, squad).
             */
            type: string;
        }

        export interface V2ShiftTimeslot {
            /**
             * Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
             */
            dayOfWeek?: string;
            /**
             * Defines the duration of each shift. (in minutes)
             */
            duration: number;
            /**
             * Defines the start hour of the each shift in the schedule timezone.
             */
            startHour: number;
            /**
             * Defines the start minute of the each shift in the schedule timezone.
             */
            startMinute: number;
        }

    }
}

export namespace service {
    export interface MaintenanceWindow {
        /**
         * Starting Time
         */
        from: string;
        /**
         * repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
         */
        repeatFrequency?: string;
        /**
         * Till when you want to repeat this Maintenance mode
         */
        repeatTill?: string;
        /**
         * End Time.
         */
        till: string;
    }

}

export namespace status {
    export interface PageOwner {
        /**
         * Status page owner id.
         */
        id: string;
        /**
         * Status page owner type Supported values are 'user' or 'squad'.
         */
        type: string;
    }

    export interface PageThemeColor {
        /**
         * Primary color.
         */
        primary: string;
        /**
         * Secondary color.
         */
        secondary: string;
    }

}

export namespace suppression {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.suppression.RulesRuleBasicExpression[];
        /**
         * description.
         */
        description?: string;
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * is_timebased will be true when users use the time based suppression rule
         */
        isTimebased: boolean;
        /**
         * The timeslots for which this rule should be applied.
         */
        timeslots?: outputs.suppression.RulesRuleTimeslot[];
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export interface RulesRuleTimeslot {
        /**
         * Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
         */
        customs?: outputs.suppression.RulesRuleTimeslotCustom[];
        /**
         * Defines the end date of the time slot
         */
        endTime: string;
        /**
         * Defines whether the time slot ends or not
         */
        endsNever?: boolean;
        /**
         * Defines the end date of the repetition
         */
        endsOn: string;
        /**
         * Defines if the time slot is an all day slot
         */
        isAllday?: boolean;
        /**
         * Defines whether repetition is custom or not
         */
        isCustom: boolean;
        /**
         * Defines the repetition of the time slot
         */
        repetition: string;
        /**
         * Defines the start date of the time slot
         */
        startTime: string;
        /**
         * Time zone for the time slot
         */
        timeZone: string;
    }

    export interface RulesRuleTimeslotCustom {
        /**
         * Determines how often the rule repeats. Valid values are day, week, month.
         */
        repeats: string;
        /**
         * Number of times to repeat.
         */
        repeatsCount?: number;
        /**
         * Repeats on month.
         */
        repeatsOnMonth: string;
        /**
         * List of weekdays to repeat on.
         */
        repeatsOnWeekdays?: number[];
    }

    export namespace rule {
        export interface V2BasicExpression {
            /**
             * left hand side dropdown value
             */
            lhs: string;
            /**
             * operator (is, is*not, matches, not*contains)
             */
            op: string;
            /**
             * right hand side value
             */
            rhs: string;
        }

        export interface V2Timeslot {
            /**
             * Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
             */
            customs?: outputs.suppression.rule.V2TimeslotCustom[];
            /**
             * Defines the end date of the time slot
             */
            endTime: string;
            /**
             * Defines whether the time slot ends or not
             */
            endsNever?: boolean;
            /**
             * Defines the end date of the repetition
             */
            endsOn: string;
            /**
             * Defines if the time slot is an all day slot
             */
            isAllday?: boolean;
            /**
             * Defines whether repetition is custom or not
             */
            isCustom: boolean;
            /**
             * Defines the repetition of the time slot
             */
            repetition: string;
            /**
             * Defines the start date of the time slot
             */
            startTime: string;
            /**
             * Time zone for the time slot
             */
            timeZone: string;
        }

        export interface V2TimeslotCustom {
            /**
             * Determines how often the rule repeats. Valid values are day, week, month.
             */
            repeats: string;
            /**
             * Number of times to repeat.
             */
            repeatsCount?: number;
            /**
             * Repeats on month.
             */
            repeatsOnMonth: string;
            /**
             * List of weekdays to repeat on.
             */
            repeatsOnWeekdays?: number[];
        }

    }
}

export namespace tagging {
    export interface RulesRule {
        /**
         * The basic expression which needs to be evaluated to be true for this rule to apply.
         */
        basicExpressions?: outputs.tagging.RulesRuleBasicExpression[];
        /**
         * The expression which needs to be evaluated to be true for this rule to apply.
         */
        expression?: string;
        /**
         * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
         */
        isBasic: boolean;
        /**
         * The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
         */
        tags?: outputs.tagging.RulesRuleTag[];
    }

    export interface RulesRuleBasicExpression {
        /**
         * left hand side dropdown value
         */
        lhs: string;
        /**
         * operator
         */
        op: string;
        /**
         * right hand side value
         */
        rhs: string;
    }

    export interface RulesRuleTag {
        /**
         * Tag color, hex values
         */
        color: string;
        /**
         * key
         */
        key: string;
        /**
         * value
         */
        value: string;
    }

    export namespace rule {
        export interface V2BasicExpression {
            /**
             * left hand side dropdown value
             */
            lhs: string;
            /**
             * operator (is, is*not, matches, not*contains)
             */
            op: string;
            /**
             * right hand side value
             */
            rhs: string;
        }

        export interface V2Tag {
            /**
             * Tag color, hex values
             */
            color: string;
            /**
             * key
             */
            key: string;
            /**
             * value
             */
            value: string;
        }

    }
}

export namespace workflow {
    export interface ActionChannel {
        /**
         * The display text of the communication channel
         */
        displayText: string;
        /**
         * The link of the communication channel
         */
        link: string;
        /**
         * The type of the communication channel
         */
        type: string;
    }

    export interface ActionComponentAndImpact {
        /**
         * The ID of the component
         */
        componentId: number;
        /**
         * The ID of the impact status
         */
        impactStatusId: number;
    }

    export interface ActionHeader {
        /**
         * The key of the header
         */
        key: string;
        /**
         * The value of the header
         */
        value: string;
    }

    export interface ActionStatusAndMessage {
        /**
         * The messages to be set for the issue
         */
        messages?: string[];
        /**
         * The ID of the status
         */
        statusId: number;
    }

}
