# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'PolicyEntityOwner',
    'PolicyRepeat',
    'PolicyRule',
    'PolicyRuleRepeat',
    'PolicyRuleRoundRobin',
    'PolicyRuleRoundRobinRotation',
    'PolicyRuleTarget',
    'GetPolicyEntityOwnerResult',
    'GetPolicyRepeatResult',
    'GetPolicyRuleResult',
    'GetPolicyRuleRepeatResult',
    'GetPolicyRuleRoundRobinResult',
    'GetPolicyRuleRoundRobinRotationResult',
    'GetPolicyRuleTargetResult',
]

@pulumi.output_type
class PolicyEntityOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Escalation policy owner id.
        :param str type: Escalation policy owner type. Supported values are 'user' or 'squad'.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Escalation policy owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Escalation policy owner type. Supported values are 'user' or 'squad'.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PolicyRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param int times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class PolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"
        elif key == "notificationChannels":
            suggest = "notification_channels"
        elif key == "roundRobin":
            suggest = "round_robin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 targets: Sequence['outputs.PolicyRuleTarget'],
                 notification_channels: Optional[Sequence[str]] = None,
                 repeat: Optional['outputs.PolicyRuleRepeat'] = None,
                 round_robin: Optional['outputs.PolicyRuleRoundRobin'] = None):
        """
        :param Sequence[str] notification_channels: Notification channels to notify the targets. (SMS, Phone, Email, Push)
        :param 'PolicyRuleRepeatArgs' repeat: repeat this rule
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "targets", targets)
        if notification_channels is not None:
            pulumi.set(__self__, "notification_channels", notification_channels)
        if repeat is not None:
            pulumi.set(__self__, "repeat", repeat)
        if round_robin is not None:
            pulumi.set(__self__, "round_robin", round_robin)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.PolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Optional[Sequence[str]]:
        """
        Notification channels to notify the targets. (SMS, Phone, Email, Push)
        """
        return pulumi.get(self, "notification_channels")

    @property
    @pulumi.getter
    def repeat(self) -> Optional['outputs.PolicyRuleRepeat']:
        """
        repeat this rule
        """
        return pulumi.get(self, "repeat")

    @property
    @pulumi.getter(name="roundRobin")
    def round_robin(self) -> Optional['outputs.PolicyRuleRoundRobin']:
        return pulumi.get(self, "round_robin")


@pulumi.output_type
class PolicyRuleRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyRuleRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyRuleRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyRuleRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: repeat after minutes
        :param int times: repeat times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        repeat after minutes
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        repeat times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class PolicyRuleRoundRobin(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 rotation: Optional['outputs.PolicyRuleRoundRobinRotation'] = None):
        """
        :param bool enabled: Enables Round Robin escalation within this layer
        """
        pulumi.set(__self__, "enabled", enabled)
        if rotation is not None:
            pulumi.set(__self__, "rotation", rotation)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enables Round Robin escalation within this layer
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rotation(self) -> Optional['outputs.PolicyRuleRoundRobinRotation']:
        return pulumi.get(self, "rotation")


@pulumi.output_type
class PolicyRuleRoundRobinRotation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyRuleRoundRobinRotation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyRuleRoundRobinRotation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyRuleRoundRobinRotation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: Optional[int] = None,
                 enabled: Optional[bool] = None):
        """
        :param int delay_minutes: repeat after minutes
        :param bool enabled: enable rotation within
        """
        if delay_minutes is not None:
            pulumi.set(__self__, "delay_minutes", delay_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> Optional[int]:
        """
        repeat after minutes
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        enable rotation within
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: ID of the target
        :param str type: Type of the target. (user, squad, schedule, schedulev2)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the target
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the target. (user, squad, schedule, schedulev2)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPolicyEntityOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Escalation policy owner id.
        :param str type: Escalation policy owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Escalation policy owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Escalation policy owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPolicyRepeatResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param int times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetPolicyRuleResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 notification_channels: Sequence[str],
                 repeats: Sequence['outputs.GetPolicyRuleRepeatResult'],
                 round_robins: Sequence['outputs.GetPolicyRuleRoundRobinResult'],
                 targets: Sequence['outputs.GetPolicyRuleTargetResult']):
        """
        :param Sequence['GetPolicyRuleRepeatArgs'] repeats: repeat this rule
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "notification_channels", notification_channels)
        pulumi.set(__self__, "repeats", repeats)
        pulumi.set(__self__, "round_robins", round_robins)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Sequence[str]:
        return pulumi.get(self, "notification_channels")

    @property
    @pulumi.getter
    def repeats(self) -> Sequence['outputs.GetPolicyRuleRepeatResult']:
        """
        repeat this rule
        """
        return pulumi.get(self, "repeats")

    @property
    @pulumi.getter(name="roundRobins")
    def round_robins(self) -> Sequence['outputs.GetPolicyRuleRoundRobinResult']:
        return pulumi.get(self, "round_robins")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetPolicyRuleTargetResult']:
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetPolicyRuleRepeatResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: repeat after minutes
        :param int times: repeat times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        repeat after minutes
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        repeat times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class GetPolicyRuleRoundRobinResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 rotations: Sequence['outputs.GetPolicyRuleRoundRobinRotationResult']):
        """
        :param bool enabled: Round Robin Escalation is an incident assignment strategy where users are placed in a ring and assigned to incidents sequentially. This strategy can help ensure that incidents are equitably distributed. It can also lower incident response time if a service experiences concurrent incidents, since the incidents will not all be assigned to the same responder.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rotations", rotations)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Round Robin Escalation is an incident assignment strategy where users are placed in a ring and assigned to incidents sequentially. This strategy can help ensure that incidents are equitably distributed. It can also lower incident response time if a service experiences concurrent incidents, since the incidents will not all be assigned to the same responder.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rotations(self) -> Sequence['outputs.GetPolicyRuleRoundRobinRotationResult']:
        return pulumi.get(self, "rotations")


@pulumi.output_type
class GetPolicyRuleRoundRobinRotationResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 enabled: bool):
        """
        :param int delay_minutes: repeat after minutes
        :param bool enabled: enable rotation within
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        repeat after minutes
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        enable rotation within
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetPolicyRuleTargetResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


