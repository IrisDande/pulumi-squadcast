# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'RulesRuleArgs',
    'RulesRuleBasicExpressionArgs',
    'RulesRuleTimeslotArgs',
    'RulesRuleTimeslotCustomArgs',
]

@pulumi.input_type
class RulesRuleArgs:
    def __init__(__self__, *,
                 is_basic: pulumi.Input[bool],
                 basic_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleBasicExpressionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 is_timebased: Optional[pulumi.Input[bool]] = None,
                 timeslots: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param pulumi.Input[Sequence[pulumi.Input['RulesRuleBasicExpressionArgs']]] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[str] description: description.
        :param pulumi.Input[str] expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[bool] is_timebased: is_timebased will be true when users use the time based suppression rule
        :param pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotArgs']]] timeslots: The timeslots for which this rule should be applied.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_timebased is not None:
            pulumi.set(__self__, "is_timebased", is_timebased)
        if timeslots is not None:
            pulumi.set(__self__, "timeslots", timeslots)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> pulumi.Input[bool]:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @is_basic.setter
    def is_basic(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_basic", value)

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleBasicExpressionArgs']]]]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @basic_expressions.setter
    def basic_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleBasicExpressionArgs']]]]):
        pulumi.set(self, "basic_expressions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="isTimebased")
    def is_timebased(self) -> Optional[pulumi.Input[bool]]:
        """
        is_timebased will be true when users use the time based suppression rule
        """
        return pulumi.get(self, "is_timebased")

    @is_timebased.setter
    def is_timebased(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_timebased", value)

    @property
    @pulumi.getter
    def timeslots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotArgs']]]]:
        """
        The timeslots for which this rule should be applied.
        """
        return pulumi.get(self, "timeslots")

    @timeslots.setter
    def timeslots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotArgs']]]]):
        pulumi.set(self, "timeslots", value)


@pulumi.input_type
class RulesRuleBasicExpressionArgs:
    def __init__(__self__, *,
                 lhs: pulumi.Input[str],
                 op: pulumi.Input[str],
                 rhs: pulumi.Input[str]):
        """
        :param pulumi.Input[str] lhs: left hand side dropdown value
        :param pulumi.Input[str] op: operator
        :param pulumi.Input[str] rhs: right hand side value
        """
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> pulumi.Input[str]:
        """
        left hand side dropdown value
        """
        return pulumi.get(self, "lhs")

    @lhs.setter
    def lhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "lhs", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        operator
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def rhs(self) -> pulumi.Input[str]:
        """
        right hand side value
        """
        return pulumi.get(self, "rhs")

    @rhs.setter
    def rhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "rhs", value)


@pulumi.input_type
class RulesRuleTimeslotArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 ends_on: pulumi.Input[str],
                 repetition: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotCustomArgs']]]] = None,
                 ends_never: Optional[pulumi.Input[bool]] = None,
                 is_allday: Optional[pulumi.Input[bool]] = None,
                 is_custom: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] end_time: Defines the end date of the time slot
        :param pulumi.Input[str] ends_on: Defines the end date of the repetition
        :param pulumi.Input[str] repetition: Defines the repetition of the time slot
        :param pulumi.Input[str] start_time: Defines the start date of the time slot
        :param pulumi.Input[str] time_zone: Time zone for the time slot
        :param pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotCustomArgs']]] customs: Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
        :param pulumi.Input[bool] ends_never: Defines whether the time slot ends or not
        :param pulumi.Input[bool] is_allday: Defines if the time slot is an all day slot
        :param pulumi.Input[bool] is_custom: Defines whether repetition is custom or not
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "ends_on", ends_on)
        pulumi.set(__self__, "repetition", repetition)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if ends_never is not None:
            pulumi.set(__self__, "ends_never", ends_never)
        if is_allday is not None:
            pulumi.set(__self__, "is_allday", is_allday)
        if is_custom is not None:
            pulumi.set(__self__, "is_custom", is_custom)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        Defines the end date of the time slot
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="endsOn")
    def ends_on(self) -> pulumi.Input[str]:
        """
        Defines the end date of the repetition
        """
        return pulumi.get(self, "ends_on")

    @ends_on.setter
    def ends_on(self, value: pulumi.Input[str]):
        pulumi.set(self, "ends_on", value)

    @property
    @pulumi.getter
    def repetition(self) -> pulumi.Input[str]:
        """
        Defines the repetition of the time slot
        """
        return pulumi.get(self, "repetition")

    @repetition.setter
    def repetition(self, value: pulumi.Input[str]):
        pulumi.set(self, "repetition", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        Defines the start date of the time slot
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        Time zone for the time slot
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotCustomArgs']]]]:
        """
        Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesRuleTimeslotCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter(name="endsNever")
    def ends_never(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether the time slot ends or not
        """
        return pulumi.get(self, "ends_never")

    @ends_never.setter
    def ends_never(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ends_never", value)

    @property
    @pulumi.getter(name="isAllday")
    def is_allday(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the time slot is an all day slot
        """
        return pulumi.get(self, "is_allday")

    @is_allday.setter
    def is_allday(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_allday", value)

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether repetition is custom or not
        """
        return pulumi.get(self, "is_custom")

    @is_custom.setter
    def is_custom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom", value)


@pulumi.input_type
class RulesRuleTimeslotCustomArgs:
    def __init__(__self__, *,
                 repeats: pulumi.Input[str],
                 repeats_count: Optional[pulumi.Input[int]] = None,
                 repeats_on_month: Optional[pulumi.Input[str]] = None,
                 repeats_on_weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] repeats: Determines how often the rule repeats. Valid values are day, week, month.
        :param pulumi.Input[int] repeats_count: Number of times to repeat.
        :param pulumi.Input[str] repeats_on_month: Repeats on month.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] repeats_on_weekdays: List of weekdays to repeat on.
        """
        pulumi.set(__self__, "repeats", repeats)
        if repeats_count is not None:
            pulumi.set(__self__, "repeats_count", repeats_count)
        if repeats_on_month is not None:
            pulumi.set(__self__, "repeats_on_month", repeats_on_month)
        if repeats_on_weekdays is not None:
            pulumi.set(__self__, "repeats_on_weekdays", repeats_on_weekdays)

    @property
    @pulumi.getter
    def repeats(self) -> pulumi.Input[str]:
        """
        Determines how often the rule repeats. Valid values are day, week, month.
        """
        return pulumi.get(self, "repeats")

    @repeats.setter
    def repeats(self, value: pulumi.Input[str]):
        pulumi.set(self, "repeats", value)

    @property
    @pulumi.getter(name="repeatsCount")
    def repeats_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to repeat.
        """
        return pulumi.get(self, "repeats_count")

    @repeats_count.setter
    def repeats_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repeats_count", value)

    @property
    @pulumi.getter(name="repeatsOnMonth")
    def repeats_on_month(self) -> Optional[pulumi.Input[str]]:
        """
        Repeats on month.
        """
        return pulumi.get(self, "repeats_on_month")

    @repeats_on_month.setter
    def repeats_on_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeats_on_month", value)

    @property
    @pulumi.getter(name="repeatsOnWeekdays")
    def repeats_on_weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of weekdays to repeat on.
        """
        return pulumi.get(self, "repeats_on_weekdays")

    @repeats_on_weekdays.setter
    def repeats_on_weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "repeats_on_weekdays", value)


