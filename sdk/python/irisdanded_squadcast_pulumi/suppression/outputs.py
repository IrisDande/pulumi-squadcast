# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'RulesRule',
    'RulesRuleBasicExpression',
    'RulesRuleTimeslot',
    'RulesRuleTimeslotCustom',
]

@pulumi.output_type
class RulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBasic":
            suggest = "is_basic"
        elif key == "basicExpressions":
            suggest = "basic_expressions"
        elif key == "isTimebased":
            suggest = "is_timebased"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_basic: bool,
                 basic_expressions: Optional[Sequence['outputs.RulesRuleBasicExpression']] = None,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 is_timebased: Optional[bool] = None,
                 timeslots: Optional[Sequence['outputs.RulesRuleTimeslot']] = None):
        """
        :param bool is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param Sequence['RulesRuleBasicExpressionArgs'] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param str description: description.
        :param str expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param bool is_timebased: is_timebased will be true when users use the time based suppression rule
        :param Sequence['RulesRuleTimeslotArgs'] timeslots: The timeslots for which this rule should be applied.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_timebased is not None:
            pulumi.set(__self__, "is_timebased", is_timebased)
        if timeslots is not None:
            pulumi.set(__self__, "timeslots", timeslots)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> bool:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[Sequence['outputs.RulesRuleBasicExpression']]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="isTimebased")
    def is_timebased(self) -> Optional[bool]:
        """
        is_timebased will be true when users use the time based suppression rule
        """
        return pulumi.get(self, "is_timebased")

    @property
    @pulumi.getter
    def timeslots(self) -> Optional[Sequence['outputs.RulesRuleTimeslot']]:
        """
        The timeslots for which this rule should be applied.
        """
        return pulumi.get(self, "timeslots")


@pulumi.output_type
class RulesRuleBasicExpression(dict):
    def __init__(__self__, *,
                 lhs: str,
                 op: str,
                 rhs: str):
        """
        :param str lhs: left hand side dropdown value
        :param str op: operator
        :param str rhs: right hand side value
        """
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> str:
        """
        left hand side dropdown value
        """
        return pulumi.get(self, "lhs")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        operator
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rhs(self) -> str:
        """
        right hand side value
        """
        return pulumi.get(self, "rhs")


@pulumi.output_type
class RulesRuleTimeslot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "endsOn":
            suggest = "ends_on"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "endsNever":
            suggest = "ends_never"
        elif key == "isAllday":
            suggest = "is_allday"
        elif key == "isCustom":
            suggest = "is_custom"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesRuleTimeslot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesRuleTimeslot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesRuleTimeslot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 ends_on: str,
                 repetition: str,
                 start_time: str,
                 time_zone: str,
                 customs: Optional[Sequence['outputs.RulesRuleTimeslotCustom']] = None,
                 ends_never: Optional[bool] = None,
                 is_allday: Optional[bool] = None,
                 is_custom: Optional[bool] = None):
        """
        :param str end_time: Defines the end date of the time slot
        :param str ends_on: Defines the end date of the repetition
        :param str repetition: Defines the repetition of the time slot
        :param str start_time: Defines the start date of the time slot
        :param str time_zone: Time zone for the time slot
        :param Sequence['RulesRuleTimeslotCustomArgs'] customs: Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
        :param bool ends_never: Defines whether the time slot ends or not
        :param bool is_allday: Defines if the time slot is an all day slot
        :param bool is_custom: Defines whether repetition is custom or not
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "ends_on", ends_on)
        pulumi.set(__self__, "repetition", repetition)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if ends_never is not None:
            pulumi.set(__self__, "ends_never", ends_never)
        if is_allday is not None:
            pulumi.set(__self__, "is_allday", is_allday)
        if is_custom is not None:
            pulumi.set(__self__, "is_custom", is_custom)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        Defines the end date of the time slot
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="endsOn")
    def ends_on(self) -> str:
        """
        Defines the end date of the repetition
        """
        return pulumi.get(self, "ends_on")

    @property
    @pulumi.getter
    def repetition(self) -> str:
        """
        Defines the repetition of the time slot
        """
        return pulumi.get(self, "repetition")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Defines the start date of the time slot
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Time zone for the time slot
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.RulesRuleTimeslotCustom']]:
        """
        Use this field to specify the custom time slots for which this rule should be applied. This field is only applicable when the repetition field is set to custom.
        """
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter(name="endsNever")
    def ends_never(self) -> Optional[bool]:
        """
        Defines whether the time slot ends or not
        """
        return pulumi.get(self, "ends_never")

    @property
    @pulumi.getter(name="isAllday")
    def is_allday(self) -> Optional[bool]:
        """
        Defines if the time slot is an all day slot
        """
        return pulumi.get(self, "is_allday")

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[bool]:
        """
        Defines whether repetition is custom or not
        """
        return pulumi.get(self, "is_custom")


@pulumi.output_type
class RulesRuleTimeslotCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatsCount":
            suggest = "repeats_count"
        elif key == "repeatsOnMonth":
            suggest = "repeats_on_month"
        elif key == "repeatsOnWeekdays":
            suggest = "repeats_on_weekdays"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesRuleTimeslotCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesRuleTimeslotCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesRuleTimeslotCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repeats: str,
                 repeats_count: Optional[int] = None,
                 repeats_on_month: Optional[str] = None,
                 repeats_on_weekdays: Optional[Sequence[int]] = None):
        """
        :param str repeats: Determines how often the rule repeats. Valid values are day, week, month.
        :param int repeats_count: Number of times to repeat.
        :param str repeats_on_month: Repeats on month.
        :param Sequence[int] repeats_on_weekdays: List of weekdays to repeat on.
        """
        pulumi.set(__self__, "repeats", repeats)
        if repeats_count is not None:
            pulumi.set(__self__, "repeats_count", repeats_count)
        if repeats_on_month is not None:
            pulumi.set(__self__, "repeats_on_month", repeats_on_month)
        if repeats_on_weekdays is not None:
            pulumi.set(__self__, "repeats_on_weekdays", repeats_on_weekdays)

    @property
    @pulumi.getter
    def repeats(self) -> str:
        """
        Determines how often the rule repeats. Valid values are day, week, month.
        """
        return pulumi.get(self, "repeats")

    @property
    @pulumi.getter(name="repeatsCount")
    def repeats_count(self) -> Optional[int]:
        """
        Number of times to repeat.
        """
        return pulumi.get(self, "repeats_count")

    @property
    @pulumi.getter(name="repeatsOnMonth")
    def repeats_on_month(self) -> Optional[str]:
        """
        Repeats on month.
        """
        return pulumi.get(self, "repeats_on_month")

    @property
    @pulumi.getter(name="repeatsOnWeekdays")
    def repeats_on_weekdays(self) -> Optional[Sequence[int]]:
        """
        List of weekdays to repeat on.
        """
        return pulumi.get(self, "repeats_on_weekdays")


